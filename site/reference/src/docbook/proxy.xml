<?xml version="1.0" encoding="UTF-8"?>
<chapter id="jms">
    <title>Connecting with JMS</title>

    <para>Citrus provides support for sending and receiving JMS messages. We have to separate between synchronous and asynchronous
    communication. So in this chapter we explain how to setup JMS message senders and receivers for synchronous and asynchronous
    outbound and inbound communication</para>
    
    <note>
        <para>Citrus provides a "citrus" configuration namespace and schema definition. Include this namespace into your Spring 
        configuration in order to use the Citrus configuration elements. The namespace URI and schema location are added to the 
        Spring configuration XML file as follows.</para>
        
        <programlisting>
  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xmlns:citrus=&quot;http://www.citrusframework.org/schema/config&quot;
         xsi:schemaLocation=&quot;
         http://www.springframework.org/schema/beans 
         http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
         http://www.citrusframework.org/schema/config 
         http://www.citrusframework.org/schema/config/citrus-config.xsd&quot;&gt;
         
      [...]
      
  &lt;/beans&gt;
        </programlisting>
        
        <para>After that you are able to use customized Citrus XML elements in order to define the Spring beans.</para>
    </note>
    
    <section id="jms-sender">
        <title>JMS message sender</title>
        
        <para>First of all we deal with asynchronous message senders, which means that Citrus is publishing messages to a JMS destination
        (queue or topic). The test case itself does not know about JMS transport details like queue names or connection 
        credentials. This information is stored in the basic Spring configuration. So let us have a look at a simple JMS message sender 
        configuration in Citrus.</para>
        
        <programlisting>
  &lt;bean id=&quot;connectionFactory&quot; 
           class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;
      &lt;property name=&quot;brokerURL&quot; 
                   value=&quot;tcp://localhost:61616&quot; /&gt;
  &lt;/bean&gt;
  
  &lt;citrus:jms-message-sender id=&quot;getOrdersRequestSender&quot; 
                                destination-name=&quot;Citrus.JMS.Order.Queue.Out&quot;/&gt;
        </programlisting>
        
        <para>The JMS connection factory is responsible for connecting to a JMS message broker. In this example we use the Apache ActiveMQ 
        connection factory implementation as we use a ActiveMQ message broker.</para>
        
        <tip>
            <para>Spring makes it very easy to connect to other JMS broker implementations too (e.g. TIBCO Enterprise Messaging Service, 
            IBM Websphere MQ). Just substitute the implementing class in the connectionFactory bean.</para>
        </tip>
        
        <note>
            <para>All of the JMS senders and receivers that require a reference to a JMS connection factory will automatically look for a bean 
            named "connectionFactory" by default. That is why you don't see a "connection-factory" attribute in many of the examples. 
            However, you can use the "connection-factory" attribute in order to use other connection factory instances with different bean 
            names.</para>
            
            <programlisting>
  &lt;citrus:jms-message-sender id=&quot;getOrdersRequestSender&quot; 
                                destination-name=&quot;Citrus.JMS.Order.Queue.Out&quot;
                                connection-factory=&quot;myConnectionFacotry&quot;/&gt;
              </programlisting> 
              
              <para>Alternatively you may want to directly specify a Spring jmsTemplate.</para>
              
              <programlisting>
  &lt;citrus:jms-message-sender id=&quot;getOrdersRequestSender&quot; 
                                destination-name=&quot;Citrus.JMS.Order.Queue.Out&quot;
                                jms-template=&quot;myJmsTemplate&quot;/&gt;
            </programlisting>
        </note>
    </section>
    
    <para>The message sender is now ready for usage inside a test. Many sending actions and test cases reference the message sender. The 
    message sender will simply publish the message to the defined JMS destination. The communication is supposed to be asynchronous, which
    means that the sender will not wait for a synchronous response. The sender fires and forgets the message immediately.</para>
    
    <section id="jms-receiver">
        <title>JMS message receiver</title>
        
        <para>Now lets deal with receiving an async message over JMS. The message receiver definition is located again in the Spring 
        configuration files. We assume that a connection factory has been configured as shown in the previous section.</para>
        
        <programlisting>
  &lt;citrus:jms-message-receiver id=&quot;getOrdersResponseReceiver&quot; 
                                  destination-name=&quot;Citrus.JMS.Order.Queue.In&quot;/&gt;
        </programlisting>
        
        <para> The receiver acts as a message driven listener. This means that the message receiver connects to the given destination 
        and waits for messages to arrive.</para>
        
        <note>
            <para>Besides the destination-name attribute you can also provide a reference to a Destination implementation.</para>
            
            <programlisting>
  &lt;citrus:jms-message-receiver id=&quot;getOrdersResponseReceiver&quot; 
                                  destination=&quot;orderInboundQueue&quot;/&gt;
            </programlisting>
            
            <para>This destination reference applies to all JMS aware message sender and receiver implementations.</para>
        </note>
    </section>
    
    <section id="jms-sync-sender">
        <title>JMS synchronous message sender</title>
        
        <para>When using synchronous message senders Citrus will define a reply-to-queue destination in the message header and wait 
        synchronously for the response on this destination.</para>
        
        <programlisting>
  &lt;citrus:jms-sync-message-sender id=&quot;getCustomerRequestSender&quot; 
                              destination-name=&quot;Citrus.JMS.Customer.Queue.Out&quot;
                              reply-handler=&quot;getCustomerReplyHandler&quot;
                              reply-timeout=&quot;1000&quot;/&gt;
                              
  &lt;citrus:jms-reply-message-handler id=&quot;getCustomerReplyHandler&quot;/&gt;      
        </programlisting>
        
        <para>To build synchronous outbound communication we need both a synchronous message sender and a reply handler. Both are defined
        in the Spring configuration. The sender sends the message and waits for the response synchronously. Once the reply has arrived the 
        reply handler is invoked with the respective reply message. The second possibility would be a timeout while receiving the reply.</para>
        
        <note>
            <para>The message sender creates a temporary JMS reply destination by default in order to receive the reply. The temporary 
            destination name is stored to the JMS replyTo message header. You can also define a static reply destination like follows.</para>
            
            <programlisting>
  &lt;citrus:jms-sync-message-sender id=&quot;getCustomerRequestSender&quot; 
                  destination-name=&quot;Citrus.JMS.Customer.Queue.Out&quot;
                  reply-destination-name=&quot;Citrus.JMS.Customer.Queue.Reply&quot;
                  reply-handler=&quot;getCustomerReplyHandler&quot;
                  reply-timeout=&quot;1000&quot;/&gt;
            </programlisting>
            
            <para>Instead of using the <emphasis>reply-destination-name</emphasis> feel free to use the destination reference
            <emphasis>reply-destination</emphasis></para>
        </note>
        
        <important>
          <para>Be aware of permissions that are mandatory for creating temporary destinations. Citrus tries to create temporary queues
          on the JMS message broker. Following from that the Citrus JMS user has to have the permission to do so. 
          Be sure that the user has the sufficient rights when using temporary reply destinations.</para>
        </important>
    </section>
    
    <section id="jms-sync-receiver">
        <title>JMS synchronous message receiver</title>
        
        <para>What is missing is the situation that Citrus receives a JMS message where a temporary reply destination is set.
        When dealing with synchronous JMS communication the requestor will store a dynamic JMS queue destination into the JMS 
        header in order to receive the synchronous answer on this dynamic destination. So Citrus has to send the reply to the 
        temporary destination, which is dynamic of course. You can handle this with the synchronous message receiver in combination 
        with a reply sender.</para>
        
        <programlisting>
  &lt;citrus:jms-sync-message-receiver id=&quot;getOrderRequestReceiver&quot; 
                      destination-name=&quot;Citrus.JMS.Order.Queue.In&quot;/&gt;
                                       
  &lt;citrus:jms-reply-message-sender id=&quot;getOrderReplySender&quot;
                      reply-destination-holder=&quot;getOrderRequestReceiver&quot;/&gt;
        </programlisting>
        
        <para>In first sight the synchronous message receiver has no difference to a normal receiver, but the difference comes in
        combination with a synchronous reply sender. The reply sender need to know the dynamic reply destination, so it desires a
        reference to a reply-destination-holder, which is our jms-sync-message-receiver.</para>
    </section>
    
</chapter>