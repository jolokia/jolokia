<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright 2009-2013 Roland Huss
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~       http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<chapter id="protocol" xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Jolokia Protocol</title>
    <para>
      Jolokia uses a JSON-over-HTTP protocol which is described in
      this chapter. The communication is based on a request-response
      paradigm, where each request results in a single response.
    </para>
  <sidebar>
    <title>GET URLs are chatty</title>
    Keep in mind
    that many web servers log the requested path of every request, including
    parameters passed to a GET request, so sending messages over GET
    often bloats server logs.
  </sidebar>
    <para>
      Jolokia requests can be sent in two ways: Either as a HTTP GET
      request, in which case the request parameters are encoded
      completely in the URL. Or as a POST request where the request is
      put into a JSON payload in the HTTP request's body. GET based
      requests are mostly suitable for simple use cases and for
      testing the agent via a browser. The focus here is on
      simplicity.  POST based requests uses a JSON representation of
      the request within the HTTP body. They are more appropriate for
      complex requests and provide some additional features (e.g. bulk
      requests are only possible with POST).
    </para>
    <para>
      The response returned by the agent uses always JSON for its data
      representation. It has the same format regardless whether GET or
      POST requests are used.
    </para>
    <para>
      The rest of this chapter is divided into two parts: First, the
      general structure of requests and responses are explained after
      which the representation of Jolokia supported operations defined.
    </para>
    <note>
      Unfortunately the term <emphasis>operation</emphasis> is
      used in different contexts which should be
      distinguished from one another. <emphasis>Jolokia operations</emphasis> denote
      the various kind of Jolokia requests, whereas <emphasis>JMX
      operations</emphasis> are methods which can be invoked on an JMX
      MBean. Whenever the context requires it, this documents uses
      <emphasis>Jolokia</emphasis> or <emphasis>JMX</emphasis> as
      prefix.  
    </note>
    <section id="request-response">
      <title>Requests and Responses</title>
      <para>
        Jolokia knows about two different styles of handling
        requests, which are distinguished by the HTTP method used: GET
        or POST. Regardless of what method is used, the agent doesn't
        keep any state on the server side (except of course that
        MBeans are obviously stateful most of the time). So in this aspect, the
        communication can be considered
       <ulink url="http://en.wikipedia.org/wiki/Representational_State_Transfer">REST</ulink>
        like<footnote id="rest-comment">
          <para>This document will avoid the term REST as much as
          possible in order to avoid provoking any dogmatic
          resentments.</para>
        </footnote>.
      </para>
      <section id="get-request">
        <title>GET requests</title>
        <para>
          The simplest way to access the Jolokia agent is by sending
          HTTP GET requests. These requests encode all their
          parameters within the access URL. Typically, Jolokia uses
          the path-info part of an URL to extract the
          parameters. Within the path-info, each part is separated by
          a slash (<literal>/</literal>).  In general, the request URL
          looks like
          <synopsis><![CDATA[<base-url>/<type>/<arg1>/<arg2>/..../]]></synopsis>
          The <literal>&lt;base-url&gt;</literal> specifies the URL
          under which the agent is accessible. It normally looks like
          <uri>http://localhost:8080/jolokia</uri>, but depends on
          your deployment setup. The last part of this URL is the
          <emphasis>context root</emphasis> of the deployed agent,
          which by default is based on the agent's filename
          (e.g. <filename>jolokia.war</filename>).
          <literal>&lt;type&gt;</literal> specifies one of the
          supported Jolokia operations (described in the next
          section), followed by one or more operation-specific
          parameters separated by slashes.
        </para>
        <para>
          For example, the following URL executes a
          <constant>read</constant> Jolokia operation on the MBean
          <literal>java.lang:type=Memory</literal> for reading the
          attribute <literal>HeapMemoryUsage</literal> (see <xref
          linkend="read"/>). It is assumed, that the agent is
          reachable under the base URL
          <uri>http://localhost:8080/jolokia</uri>: 
          <informalexample>
            <literallayout class="monospaced">http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage</literallayout>
          </informalexample>
        </para>
        <sidebar>
          <title>
            Why escaping ?
          </title>
          You might wonder why simple URI encoding isn't enough for
          escaping slashes. The reason is that JBoss/Tomcat has a
          strange behaviour when returning an HTTP response
          <literal>HTTP/1.x 400 Invalid URI: noSlash</literal> for
          any URL which contains an escaped slash in the path info
          (i.e. <literal>%2F</literal>). The reason behind this
          behaviour is security related, slashes get decoded on the
          agent side before the agent-servlet gets the
          request. Other appservers might exhibit a similar
          behaviour, so Jolokia uses an own escaping mechanism. 
        </sidebar>
        <para>
          If one of the request parts contain a slash
          (<literal>/</literal>) (e.g. as part of you bean's name) it
          needs to be escaped. An exclamation mark
          (<literal>!</literal>) is used as escape character<footnote
          id="no-backslash">
          <para>
            A backslash (<literal>\</literal>) can not be used, since
            most servlet container translate a backslash into a forward
            slash on the fly when given in an URL. 
          </para>
          </footnote>. An exclamation mark itself needs to be doubled
          for escaping. Any other characted preceded by an exclamation
          mark is taken literally. Table <xref
          linkend="escape-rules"/> illustrates the escape rules as
          used in GET requests. Also, if quotes are part of an GET
          request the need to be escaped  with
          <constant>!"</constant>. 
        </para>
        <table id="escape-rules">
          <title>Escaping rules</title>
          <thead>
            <tr>
              <td>Escaped</td>
              <td>Unescaped</td>
            </tr>        
          </thead>
          <tr>
            <td><constant>!/</constant></td>
            <td><constant>/</constant></td>
          </tr>
          <tr>
            <td><constant>!!</constant></td>
            <td><constant>!</constant></td>
          </tr>
          <tr>
            <td><constant>!"</constant></td>
            <td><constant>"</constant></td>
          </tr>
          <tr>
            <td><constant>!</constant><emphasis>(anything else)</emphasis></td>
            <td><emphasis>(anything else)</emphasis></td>
          </tr>
        </table>
        <para>
          For example, to read the atrribute <literal>State</literal>
          on the MBean named
          <literal>jboss.jmx:alias=jmx/rmi/RMIAdaptor</literal>, an
          access URL like this has to be constructed:
        </para>        
        <informalexample>
          <literallayout class="monospaced">.../read/jboss.jmx:alias=jmx!/rmi!/RMIAdaptor/State</literallayout>
        </informalexample>
        <para>
          Client libraries like <ulink
          url="http://search.cpan.org/~roland/jmx4perl">JMX::Jmx4Perl</ulink>
          do this sort of escaping transparently. 
        </para>
       <para>
          Escaping can be avoided alltogether if a slightly different
          variant for a request is used (which doesn't look that
          REST-stylish, though). Instead of providing the information
          as path-info, a query parameter <literal>p</literal> can be
          used instead. This should be URL encoded, though. For the
          example above, the alternative is
          <informalexample>
            <literallayout class="monospaced">http://localhost:8080/jolokia?p=/read/jboss.jmx:alias=jmx%2Frmi%2FRMIAdaptor/State</literallayout>
          </informalexample>
          This format <emphasis>must</emphasis> be used for GET
          requests containing backslashes (<literal>\</literal>) since
          backslashes can not be sent as part of an URL at all.          
        </para>
      </section>

      <section id="post-request">
        <title>POST requests</title>
        <para>
          POST requests are the most powerful way to communicate
          with the Jolokia agent. There are fewer escaping issues and it
          allows for features which are not available with GET
          requests. POST requests uses a fixed URL and put their payload
          within the HTTP request's body. This payload is represented
          in <ulink url="http://www.json.org">JSON</ulink>, a
          data serialization format originating from JavaScript
          world.
        </para>
        <para>
          The JSON format for a single request is a JSON object, which
          is essentially a map with keys (or
          <emphasis>attributes</emphasis>) and values. All requests
          have a common mandatory attribute,
          <constant>type</constant>, which specifies the kind of JMX
          operation to perform. The other attributes are either
          operation specific as described in <xref
          linkend="jolokia-operations"/> or are <emphasis>processing
          parameters</emphasis> which influence the overall behaviour
          and can be mixed in to any request. See <xref
          linkend="processing-parameters"/> for details.
        </para>
        <para>
          A sample read request in JSON format looks like the
          following example. It has a <constant>type</constant>
          "read"
          (case doesn't matter) and the three attributes
          <constant>mbean</constant>, <constant>attribute</constant>
          and <constant>path</constant> which are specific to a read
          request. 
        </para>
        <example id="request-example">
          <title>JSON Request</title>
          <programlisting><![CDATA[
  {
    "type" : "read",
    "mbean" : "java.lang:type=Memory",
    "attribute" : "HeapMemoryUsage",
    "path" : "used",
  }]]></programlisting>
        </example>
        <para>
          Each request JSON object results in a single JSON response
          object contained in the HTTP answer's body. A <emphasis>bulk
          request</emphasis> contains multiple Jolokia requests within
          a single HTTP request. This is done by putting individual
          Jolokia requests into a JSON array:
        </para>
        <programlisting><![CDATA[
 [
  {
    "type" : "read",
    "attribute" : "HeapMemoryUsage",
    "mbean" : "java.lang:type=Memory",
    "path" : "used",
  },
  { 
    "type" : "search"
    "mbean" : "*:type=Memory,*",
  }
 ]]]></programlisting>
        <para>
          This request will result in a JSON array containing multiple
          JSON responses within the HTTP response. They are returned
          in same order as the requests in the initial bulk request.
        </para>
      </section>
      
      <section id="responses">
        <title>Responses</title>
        <para>
          Responses are always encoded in UTF-8 JSON, regardless whether the
          requst was a GET or POST request.  In general, two kinds of
          responses can be classified: In the normal case, a HTTP
          Response with response code 200 is returned, containing the
          result of the operation as a JSON payload. In case of an
          error, a 4xx or 5xx code will be returned and the JSON
          payload contains details about the error
          occured (e.g. 404 means "not found"). (See
          <ulink url="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes">this page</ulink>
          for more information about HTTP error codes..). If the processing option
          <constant>ifModifiedSince</constant> is given and the requested
          value as been not changed since then, a response code of 304 is returned.
          This option is currently only supported by the <constant>LIST</constant> request, for
          other request types the value is always fetched.
        </para>
        <para>
          In the non-error case a JSON response looks mostly the same
          for each request type except for the
          <constant>value</constant> attribute which is request type
          specific. 
        </para>
        <para>
          The format of a single Jolokia response is
        </para>
        <example id="response-example">
          <title>JSON Response</title>
          <programlisting><![CDATA[
 {
   "value": .... ,
   "status" : 200,
   "timestamp" : 1244839118,
   "request": {
               "type": ...,
               ....
              },
   "history":[
               {"value": ... ,
                "timestamp" : 1244839045
               }, ....
             ]
 }]]></programlisting>
        </example>
        <para>
          For successful requests, the <constant>status</constant> is
          always <literal>200</literal> (the HTTP success code). The
          <constant>timestamp</constant> contains the epoch
          time<footnote id="epoch-time">
          <para>
            Seconds since 1.1.1970
          </para>
          </footnote> when the
          request has been handled. The request leading to this
          response can be found under the attribute
          <constant>request</constant>. Finally and optionally, if
          history tracking is switched on (see <xref
          linkend="history"/>), an entry with key
          <constant>history</constant> contains a list of historical
          values along with their timestamps. History tracking is only
          available for certain type of requests
          (<constant>read</constant>, <constant>write</constant> and
          <constant>exec</constant>). The <constant>value</constant>
          is specific for the type of request, it can be a single
          scalar value or a monster JSON structure.
        </para>
        <para>
          If an error occurs, the <constant>status</constant> will be
          a number different from <literal>200</literal>. An error
          response looks like
        </para>
        <programlisting><![CDATA[
  {
    "status":400,
    "error_type":"java.lang.IllegalArgumentException",
    "error":"java.lang.IllegalArgumentException: Invalid request type 'java.lang:type=Memory'",
    "stacktrace":"java.lang.IllegalArgumentException: Invalid request type 'java.lang:type=Memory'\n
                  \tat org.cpan.jmx4perl.JmxRequest.extractType(Unknown Source)\n
                  \tat org.cpan.jmx4perl.JmxRequest.<init>(Unknown Source) ...."
  }]]></programlisting>
        <para>
            For status codes it is important to distinguish status
            codes as they appear in Jolokia JSON response objects
            and the HTTP status code of the (outer) HTTP
            response. There can be many Jolokia status codes, one for
            each Jolokia request contained in the single HTTP request. The
            HTTP status code merely reflect the status of agent itself
            (i.e. whether it could perform the operation at all), whereas the
            Jolokia response status reflects the result of the
            operation (e.g. whether the performed operation throws an
            exception). So it is not uncommon to have an HTTP status
            code of 200, but the contained JSON response(s) indicate
            some errors.
        </para>
        <para>
          I.e. the <constant>status</constant> has a code in the range
          <literal>400 .. 499</literal> or <literal>500 .. 599</literal>
          <ulink url="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes">as it is specified for HTTP return codes</ulink>.
          The <constant>error</constant> member contains an error
          description. This is typically the message of an exception
          occured on the agent side<footnote
          id="mbeanexception-wrapping">
          <para>
            If the server exception
            is a subtype of <classname>MBeanException</classname>, the wrapped
            exception's message is used.
          </para>
          </footnote>. Finally, <constant>error_type</constant> contains the Java class name
          of the exception occured.
          The <constant>stacktrace</constant> contains a Java stacktrace
          occured on the server side (if any stacktrace is available).
          </para>

        <para>
          For each type of operation, the format of the
          <constant>value</constant> entry is explained in
          <xref linkend="jolokia-operations"/>
        </para>
      </section>
      
      <section id="paths">
        <title>Paths</title>
        <para>
          An <emphasis>inner path</emphasis> points to a certain
          substructure (plain value, array, hash) within a a complex
          JSON value. Think of it as something like "XPath lite". This
          is best explained by an example:
        </para>
        <para>
          The attribute <literal>HeapMemoryUsage</literal> of the MBean 
          <literal>java.lang:type=Memory</literal> can be
          requested with the URL 
          <literal>http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage</literal>
          which returns a complex JSON structure like
          <programlisting language="json">
 {
   "committed" : 18292736,
   "used" : 15348352,
   "max" : 532742144,
   "init" : 0
 }</programlisting>
        </para>
        <para>
          In order to get to the value for used heap memory you should
          specify an inner path <literal>used</literal>, so that the
          request
          <literal>http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage/used</literal>
          results in a response of <literal>15348352</literal>.  If
          the attribute contains arrays at some level, use a numeric
          index (0 based) as part of the inner path if you want to
          traverse into this array.
        </para>    
        <para>
          For both, GET and POST requests, paths must be escaped as
          described in <xref linkend="escape-rules"/> when they
          contain slashes (<literal>/</literal>) or exclamation marks
          (<literal>!</literal>).
        </para>
      </section>
    </section>
    
    <section id="jolokia-operations">
      <title>Jolokia operations</title>

      <xi:include href='protocol/read.xml'/>
      <xi:include href='protocol/write.xml'/>
      <xi:include href='protocol/exec.xml'/>
      <xi:include href='protocol/search.xml'/>
      <xi:include href='protocol/list.xml'/>
      <xi:include href='protocol/version.xml'/>

    </section>
        
    <section id="processing-parameters">
      <title>Processing parameters</title>
      <para>
        Jolokia operations can be influenced by so-called
        <emphasis>processing parameters</emphasis>. These parameters
        are provided differently for POST and GET requests.
      </para>
      <para>
        For GET request, the processing parameter are given as normal
        query parameters:
        <synopsis><![CDATA[<GET request URL>?param1=value1&param2=value2&...]]></synopsis>
        For example the request
        <synopsis><![CDATA[http://localhost:8080/jolokia/list?maxObjects=100]]></synopsis>
        will limit the response to at max 100 values.
      </para>
      <para>
        POST request take the processing instructions within the
        JSON request below the key <constant>config</constant>:
      </para>
        <programlisting><![CDATA[
  {
    "type" : "list"
    "config" : { 
                 "maxObjects" : 100
               } 
  }]]></programlisting>
      <para>
        If a POST request carries also query parameters in the URL, these processing parameters
        are merged with the ones given within the request. Configuration options given in the
        request take precedence over the ones given as query parameters.
      </para>
      <para>
        The list of known processing parameters is:
      </para>
      <variablelist>
        <varlistentry>
          <term><literal>maxDepth</literal></term>
          <listitem>
            <para>
              Maximum depth of the tree traversal into a bean's
              properties. The maximum value as configured in the
              agent's configuration is a hard limit
              and cannot be exceeded by a query parameter.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>maxCollectionSize</literal></term>
          <listitem>
            <para>
              For collections (lists, maps) this is the maximum
              size. 
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>maxObjects</literal></term>
          <listitem>
            <para>
              Number of objects to visit in total. A hard limit
              can be configured in the agent's configuration. 
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>ignoreErrors</literal></term>
          <listitem>
            <para>
              If set to "true", a Jolokia operation will not return an
              error if an JMX operation fails, but includes the
              exception message as value. This is useful for e.g. the
              read operation when requesting multiple attributes'
              values. Default: false 
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>mimeType</literal></term>
          <listitem>
            <para>
              The MIME type to return for the response. By default,
              this is <literal>text/plain</literal>, but it can be
              useful for some tools to change it to
              <literal>application/json</literal>. Init parameters can
              be used to change the default mime type.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>canonicalNaming</literal></term>
          <listitem>
            <para>
              Defaults to <constant>true</constant> to return the canonical format of property lists.
              If set to <constant>false</constant> then the default unsorted property list is returned.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>includeStackTrace</literal></term>
          <listitem>
            <para>
              If set to <constant>true</constant>, then in case of an error the stack trace is included. 
              With <constant>false</constant> no stack trace will be returned, and when this parameter
              is set to <constant>runtime</constant> only for RuntimeExceptions a stack trace is put into 
              the error response. Default is <constant>true</constant> if not set otherwise in the global
              agent configuration.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>serializeException</literal></term>
          <listitem>
            <para>
              If this parameter is set to <constant>true</constant> then a serialized version of the
              exception is included in an error response. This value
              is put under the key <constant>error_value</constant> in
              the response value. By default this is set to
              <constant>false</constant> except when the agent global
              configuration option is configured otherwise.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><literal>ifModifiedSince</literal></term>
          <listitem>
            <para>
              If this parameter is given, its value is interpreted as epoch time (seconds since 1.1.1970) and
              if the requested value did not change since this time, an empty response (with no <constant>value</constant>)
              is returned and the response status code is set to 304 ("Not modified"). This
              option is currently only supported for <literal>LIST</literal> requests. The time value can be
              extracted from a previous' response <constant>timestamp</constant>.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    
    <section id="serialization">
      <title>Object serialization</title>
      <para>
        Jolokia has some object serialization facilities in order to
        convert complex Java data types to JSON and vice
        versa. Serialization works in both ways in requests and
        responses, but the capabilities differ.
      </para>
      <para>
        Complex data types returned from the agent can be serialized
        completely into a JSON value object. It can detect cycles in
        the object graph and provides a way to limit the depth of
        serialization. For certain types (like
        <classname>File</classname> or
        <classname>ObjectName</classname>) it uses simplifier to not
        expose internal and redundant information. 
      </para>
      <para>
        Object values used for values in 
        <emphasis>write</emphasis> operations and arguments in
        <emphasis>exec</emphasis>, type support is limited to a
        handful of data types.
      </para>
      <section id="serialization-response">
        <title>Response value serialization</title>
        <para>
          Jolokia can serialize any object into a JSON representation
          when generating the response. It uses some specific
          converters for certain well known data type with a generic
          bean converter as fallback.
        </para>
        <para>
          The following types are directly supported:
          <itemizedlist>
            <listitem>
              Arrays and <classname>java.util.List</classname>
              are converted to JSON arrays
            </listitem>
            <listitem>
              <classname>java.util.Map</classname> gets
              converted into a JSON object. Note, however, that JSON
              Object keys are <emphasis>always strings</emphasis>.
            </listitem>
            <listitem>
              Enums are converted to their canonical name.<footnote id="enum-serial-jboss">
              <para>
                For JBoss older than version 7, there might be use cases
                when custom enums need to be serialized. In this case,
                the type information must be available to the agent,
                too. For the standard PlatformMBeanServer
                serialization should work always, regardless whether
                the customer enum type is accessible by the agent or
                not.
              </para>
            </footnote>
            </listitem>
            <listitem>
              <classname>javax.management.openmbean.CompositeData</classname>
              is converted in a JSON object, with the keys taken from
              the <classname>CompositeData</classname>'s key set and
              the value are its values.
            </listitem>
            <listitem>
              <classname>javax.management.openmbean.TabularData</classname>
              is serialized into one or multiple nested JSON objects
              where the keys are derived from its
              <methodname>TabularType.indexName()</methodname>. If
              there is a single valued index, the index's value is the
              key and a <classname>TabularData</classname>'s row
              (which in turn is a
              <classname>CompositeData</classname>) is a map. With
              multi valued keys, the map is nested (first level: first
              index's value, second level: second index's value and so
              on). For the serialization of <classname>TabularData</classname> resulting
              from a <classname><ulink
              url="http://download.oracle.com/javase/6/docs/api/javax/management/MXBean.html">MXBean</ulink></classname> translation for
              maps, see <xref linkend="serialization-mxbean"/>
            </listitem>
            <listitem>
              <classname>java.lang.Class</classname> is converted to
              a JSON object with keys <literal>name</literal> (the class
              name) and <literal>interfaces</literal> (the implemented
              interfaces, if any)
            </listitem>
            <listitem>
              <classname>java.io.File</classname> becomes a JSON
              object with keys <literal>name</literal> (file name),
              <literal>modified</literal> (date of last modification),
              <literal>length</literal> (file size in bytes),
              <literal>directory</literal> (whether the file is a directory),
              <literal>canonicalPath</literal> (the canonical path)
              and <literal>exists</literal>.
            </listitem>
            <listitem>
              <classname>javax.management.ObjectName</classname> is
              converted into a JSON object with the single key
              <literal>objectName</literal>. 
            </listitem>
            <listitem>
              <classname>java.net.URL</classname> becomes a JSON
              object with the key <literal>url</literal> containing
              the URL as String.
            </listitem>
            <listitem>
              <classname>java.util.Date</classname> is represented in
              an ISO-8601 format. When used with a path
              <literal>time</literal> the milliseconds since 1.1.1970
              00:00 UTC are returned.
            </listitem>
            <listitem>
              <classname>org.w3c.dom.Element</classname> is translated
              into a JSON object with the properties
              <literal>name</literal>, <literal>value</literal> and
              <literal>hasChildNodes</literal>.
            </listitem>
          </itemizedlist>
        </para>
        <para>
          Primitive and simple types (like String) are
          directly converted into their string presentation. All
          objects not covered by the list above are serialized in JSON
          objects, where the keys are the public bean properties of
          the object and the values are serialized (recursively) as
          described.
        </para>
        <para>
          Serialization can be influenced by certain processing
          parameters given with the request (see <xref
          linkend="processing-parameters"/>). I.e. the recursive
          process of JSON serialization can be stopped when the data
          set gets too large. Self and other circular references
          are detected, too. If this happen, special values indicate
          the truncation of the generated JSON object.
        </para>
        <variablelist>
          <varlistentry>
            <term><constant>[this]</constant></term>
            <listitem>
              <para>
                This label is used when a property contains a self reference 
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><constant>[Depth limit .... ]</constant></term>
            <listitem>
              <para>
                When a depth limit is used or the hard depth limit
                is exceeded, this label contains a string
                representation of the next object one level deeper.
                (see <xref linkend="processing-parameters"/>,
                parameter <literal>maxDepth</literal>)
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><constant>[Reference .... ]</constant></term>
            <listitem>
              <para>
                If during the traversal an object is visited a second time, this label is
                used in order to break the cycle. 
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term><constant>[Object limit exceeded]</constant></term>
            <listitem>
              <para>
                The total limit of object has been exceeded and hence
                the object are not deserialized further.  (see <xref
                linkend="processing-parameters"/>, parameters
                <literal>maxCollectionSize</literal> and
                <literal>maxObjects</literal>)
              </para>
            </listitem>
          </varlistentry>
        </variablelist>  
      </section>
      
      <section id="serialization-request">
        <title>Request parameter serialization</title>
        <para>
          Serialization in the upstream direction (i.e. when sending
          values for <constant>write</constant> operations or arguments
          for <constant>exec</constant> operations) differs from
          from the object serializaton as used as response values
          which is described in <xref
          linkend="serialization-response"/>. Not all types are
          supported for upstream serialization <footnote id="upstream-serialization-comment">
            <para>
              Conversion from a typed system to an untyped
              representation is obviously much easier than vice
              versa. Please note, that Jolokia does not replace a full
              blown JSON object serialization framework like
              Jackson. Nor does it use one in order to keep the agent small
              and simple with a low dependency count.
            </para>
          </footnote>
          and the capabilities differ also for POST and GET requests.
          <literal>GET</literal> upstream serialization is limited to
          basic types and simple arrays. POST requests on the other
          support a much large set of types, including the
          serialization of <constant>Map</constant>s, 
          <constant>List</constant>s and all <ulink
          url="http://download.oracle.com/javase/6/docs/api/javax/management/openmbean/OpenType.html">Open
          Types</ulink>. 
        </para>
        <section>
          <title>GET request values</title>
          <para>
            Since parameters get encoded in the URL for GET request,
            only the following types can used for values and arguments
            in <constant>write</constant> and
            <constant>exec</constant> requests:
            <itemizedlist>
              <listitem>String</listitem>
              <listitem>Integer / int</listitem>
              <listitem>Long / long</listitem>
              <listitem>Byte / byte</listitem>
              <listitem>Short / short</listitem>
              <listitem>Float / float</listitem>
              <listitem>Double / double</listitem>
              <listitem>BigDecimal / BigInteger</listitem>
              <listitem>URL / URL</listitem>
              <listitem>char</listitem>
              <listitem>Boolean / boolean</listitem>
              <listitem>Date</listitem>
              <listitem>Enums (whose type is accessible to the agent,
              see below)</listitem>
            </itemizedlist>
          </para>
          <para>
            The serialized value is simply the string representation
            of those types. Dates can be set either by an long value
            (epoch milliseconds) or with a string value (ISO-8601
            format). Arrays of the given types are serialized as a
            comma separated list.
          </para>
          <note>
            The array support is somewhat limited since it makes a
            native split on commas. It does not yet take into account
            any quoting or escaping. For a much safer way to transport
            arrays to the agent, please consider using POST requests.
          </note>
          <para>
            Certain <emphasis>tag values</emphasis> are used to mark special
            values.  A <constant>null</constant> value has to be
            serialized as <literal>[null]</literal>, an empty String
            as <literal>""</literal>. Tag values are not required for
            POST requests.
          </para>
        </section>
        <section>
          <title>POST request values</title>
          <para>
            POST request take advantage of the JSON type of the value
            transfered. These are basic types for numbers
            (<literal>42</literal> or <literal>23.5</literal>),
            booleans (<literal>true</literal> or
            <literal>false</literal>) and strings
            (<literal>"habanero"</literal>). Also, JSON knows about
            <constant>null</constant> values so no special 'tags' like
            for GET requests are not required. Since JSON supports
            intrinsically key-value maps and array types, these can be
            used directly, too. I.e. if the JMX operation to execute
            takes a <constant>Map</constant> argument, the argument
            can be given as a JSON object. Be aware, however, that JSON
            maps (objects) only support strings as keys.
          </para>
          <para>
            The agent knows how to convert an JSON array to Java
            Arrays (of a basic type) or Lists, depending on the
            requirement as dictated by the MBeans operation or
            attribute signature. Numbers in JSON are always transfered
            as long or double values and are as well tried to fit 
            to the MBean's signature. In case of an overflow
            (e.g. when trying to treat a long with a too large value
            as int), an exception is raised.
          </para>
          <para>
            Enums can be converted from their canonical name. The
            prerequisite for this is, that the Jolokia agent has
            access to the Enum's class. This is true for all Enums
            shipped with the JDK (like
            <classname>TimeUnit</classname>). Custom enums can not be
            used for upstream serialization by default since the
            Jolokia Agent is not able to contruct an instance of it
            because of missing type information.
          </para>
          <para>
            Upstream serialization also supports <ulink
            url="http://download.oracle.com/javase/6/docs/api/javax/management/openmbean/OpenType.html">OpenType</ulink>s.
            If the signature of JMX exec operation or the value type
            of a JMX attribute is a <classname>OpenType</classname>,
            they are serialized as follows:            
          </para>
          <itemizedlist>
            <listitem>
              <classname>SimpleType</classname>s are extracted from
              their corresponding JSON type. 
            </listitem>
            <listitem>
              <classname>ArrayType</classname> is extracted from a
              <classname>JSONArray</classname> where the elements are
              serialized recursively with this algorithms. Only
              <classname>ArrayType</classname>s with element type
              <classname>CompositeType</classname> or
              <classname>SimpleType</classname> are supported. 
            </listitem>
            <listitem>
              <classname>CompositeType</classname> is extracted
              recursively from a <classname>JSONObject</classname>
              where there the string keys must fit to the
              <classname>CompositeType</classname>'s item names and
              the values must be serializable as open types.
            </listitem>
            <listitem>
              <para>
                <classname>TabularType</classname> is converted from
                <classname>JSONObject</classname>. If it is single index
                (i.e. has only one single index name), the
                <classname>JSONObject</classname> must have the index
                values as string keys and the map values are other
                <classname>JSONObject</classname>s representing the row
                data. For <classname>TabularType</classname>s with more
                than one index name, the incoming
                <classname>JSONObjecct</classname> must be a nested
                object with each index as an additional
                layer. E.g. the following JSON object works for 
                a <classname>TabularType</classname> with the two
                index names <literal>lastname</literal> and
                <literal>firstname</literal>:
              </para>
        <programlisting language="perl"><![CDATA[{ 
  "Mann": {
           "Thomas": {
                      lastname: "Mann",
                      firstname: "Thomas",
                      birth: 1875
                     },
           "Heinrich": {
                        lastname: "Mann",
                        firstname: "Heinrich",
                        birth: 1871
                       }
          }
}]]></programlisting>
              <para>
                <classname>TabularType</classname> used by the MXBean
                framework for serialization of Maps are translated
                directly from maps. More details are explained in the
                next section <xref linkend="serialization-mxbean"/>.
              </para>
            </listitem>
          </itemizedlist>
          
        </section>
      </section>

      <section id="serialization-mxbean">
        <title>Jolokia and MXBeans</title>
        <para>
          The <ulink url="http://download.oracle.com/javase/6/docs/api/javax/management/MXBean.html">MXBean Framework</ulink> is availale in
          the JRE since version 6 and allows for easy creation and
          registration of own MBeans. MXBeans are some what the
          successor for standard MBeans and support an annotation driven
          as well as a naming convention driven programming model. The
          most important difference to standard MBeans it the
          restriction of MXBean to reference only open types.
        </para>
        <para>
          Although to the outside only open types are exposed by the
          MXBean framework, MXBean themselves can use more complex
          data types. The framework will translate forth and back
          between the custom and open types according to certain rules
          as declared in the MXBean <ulink
          url="http://download.oracle.com/javase/6/docs/api/javax/management/MXBean.html">specification</ulink>. 
          Most of the translations to open types fits naturally to
          Jolokia's serialization, except for the translation of Map.
        </para>
        <para>
          When an MXBean references a map, the MXBean framework
          translates this map into a
          <classname>TabularData</classname> with a fixed internal
          structure, i.e. with an index <literal>key</literal> and
          rows with keys <literal>key</literal> and
          <literal>value</literal>. This leads directly to a JSON
          representation which is quite artificial. E.g a map with 
          two keys <literal>kind</literal> and
          <literal>hotness</literal> will be converted by the MXBean
          framework to a TabularData object which in turn would be
          translated by Jolokia to the following JSON struture
        </para>
      <programlisting><![CDATA[{
  "kind" : { 
             "key": "kind",
             "value": "Habanero"
           }, 
  "hotness" : {
                "key": "hotness",
                "value": 10
              }
}]]></programlisting>
      <para>
        Since this representation of a simple map is unnecessarily
        complicated, Jolokia treats <classname>TabularData</classname>
        of this kind (i.e. one index <literal>key</literal> and rows
        with properties <literal>key</literal> and
        <literal>value</literal>) specially in order to translate it
        back (and forth) to
      </para>
      <programlisting><![CDATA[{
  "kind" : "Habanero", 
  "hotness" : 10
}]]></programlisting>            
      </section>
      
    </section>

    <section id="history">
      <title>Tracking historical values</title>
      <para>
        The Jolokia agents are able to keep requested values in memory
        along with a timestamp. If history tracking is switched on,
        then the agent will put the list of historical values specific
        for this request into the response. History tracking is
        toggled by an MBean operation on a Jolokia-owned MBean (see
        <xref linkend="mbeans"/>). This has to be done individually for each
        attribute or JMX operation to be tracked.
      </para>
      <para>
        A <constant>history</constant> entry is contained in every
        response for which history tracking was switched on. A certain
        JMX operation on an Jolokia specific MBean has to be executed
        to turn history tracking on for a specific attribute or
        operation. See <xref linkend="mbeans"/> for details.The
        <constant>history</constant> property of the JSON response
        contains an array of json objects which have two attributes:
        <constant>value</constant> containing the historical value
        (which can be as complex as any other value) and
        <constant>timestamp</constant> indicating the time when this
        value was current (as measured by the server). <xref
        linkend="response-example"/> has an example of a response
        containing historical values. 
      </para>
      <para>
        For multi attribute read requests, the history entry in the
        response is a JSON object instead of an array, where this
        object's attributes are the request's attribute names and the
        values are the history arrays as described above.
      </para>
    </section>

    <section id="protocol-proxy">
      <title>Proxy requests</title>
      <para>
        For proxy requests, POST must be used as HTTP method so that
        the given JSON request can contain an extra section for the
        target which should be finally reached via this proxy
        request. A typical proxy request looks like
      </para>
      <programlisting><![CDATA[
  {
    "type" : "read",
    "mbean" : "java.lang:type=Memory",
    "attribute" : "HeapMemoryUsage",
    "target" : { 
         "url" : "service:jmx:rmi:///jndi/rmi://targethost:9999/jmxrmi",
         "user" : "jolokia",
         "password" : "s!cr!t"
    } 
  }]]></programlisting>
      <para>
        <literal>url</literal> within the <literal>target</literal>
        section is a JSR-160 service URL for the target server
        reachable from within the proxy agent. <literal>user</literal>
        and <literal>password</literal> are optional credentials used
        for the JSR-160 communication.
      </para>
    </section>
    
    <section id="versions">
      <title>Jolokia protocol versions</title>
      <para>
        The protocol definition is versioned. It contains of a major
        and minor version. Changes in the minor version are backward
        compatible to other protocol with the same major
        version. Major version changes incorporate possibly backwards
        incompatible changes. This document describes the Jolokia
        protocol version <emphasis role="bold">7.0</emphasis>
      </para>
      <variablelist>
        <varlistentry>
          <term><emphasis role="bold">7.0</emphasis> (since 1.1.0)</term>
          <listitem>
            <para>
              The <emphasis
              role="bold"><constant>maxDepth</constant></emphasis>
              parameter (either as processing parameter or as
              configuration value) is now 1 based. I.e. 0 means always
              "no limit" (be careful with this, though), 1 implies
              truncating the value on the first level for READ
              request. This was already true for LIST requests and the
              other limit values (maxCollectionSize and maxObjects) so
              this change is used in order to harmonize the overall
              behaviour with regard to limits.
            </para>
          </listitem>
          <listitem>
            <para>
              Enums are now serialized downstream (full support)
              and upstream (for type accessible to the agent).
            </para>
          </listitem>
          <listitem>
            <para>
              New query parameter options
              <constant>serializeException</constant> (for setting an
              <constant>error_value</constant> in case of an
              exception), <constant>canonicalNaming</constant>
              (influences how object names are returned) and
              <constant>includeStackTrace</constant> (for adding or
              omitting stacktraces in error responses).
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><emphasis role="bold">6.1</emphasis> (since 1.0.2)</term>
          <listitem>
            <para>
              Error responses contain now the original request as
              well, for single and bulk requests.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><emphasis role="bold">6.0</emphasis> (since 1.0.0)</term>
          <listitem>
            <para>
              Escaping has been changed from <literal>/-/</literal> to
              <literal>!/</literal>. This affects GET Urls and
              <emphasis> inner paths</emphasis>.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><emphasis role="bold">5.0</emphasis> (since 0.95)</term>
          <listitem>
            <para>
              <classname>javax.management.openmbean.TabularData</classname>
              is serialized differently when generating the
              response. In fact, the serialization as an array in
              the former versions of this protocol is not correct,
              since <classname>TabularData</classname> in fact is a
              hash and not a list. It is now generated as map (or
              multiple maps), depending on the declared
              <emphasis>index</emphasis>. Also, access via path is now
              an access via key, not a list index. For the special
              case of MXBean map serialization, where the returned
              <classname>TabularData</classname> has a fixed format
              (i.e. with <literal>key</literal> and
              <literal>value</literal> columns), the
              <classname>TabularData</classname> is transformed to an
              appropriate map.. 
            </para>
          </listitem>
          <listitem>
            <para>
              Removed JSON property <literal>modified</literal> from
              the serialized JSON representation of a File return
              value since it duplicated the
              <literal>lastModified</literal> property on the same
              object. 
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><emphasis role="bold">4.3</emphasis> (since 0.91)</term>
          <listitem>
            <para>
              The <literal>list</literal> operation supports a
              <literal>maxDepth</literal> option for truncating the
              answer. 
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><emphasis role="bold">4.2</emphasis> (since 0.90)</term>
          <listitem>
            <para>
              Response values are returned in the native JSON
              datatype, not always as strings as in previous versions
              of this protocol. Parameter serialization for writing
              attribute values or for arguments in exec operations has
              been enhanced for POST requests, which are now
              represented as native JSON types and not in a string
              representation as before. GET requests still use a
              simplified string representation.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><emphasis role="bold">4.0</emphasis> (17.10.2010)</term>
          <listitem>
            <para>This is the initial version for Jolokia. Versions below 4 are
            implemented by jmx4perl</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
</chapter>
