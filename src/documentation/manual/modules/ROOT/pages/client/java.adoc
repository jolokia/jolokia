////
  Copyright 2009-2026 Roland Huss

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
////
[#client-java]
== Java Client Library

NOTE: This documentation section is related to the current Jolokia version.
For previous Jolokia versions the chapter is available here:
xref:client/java-old.adoc[Java Client Library (Jolokia versions before 2.4.0)]

The Java client library provides an easy access to the Jolokia
Agent using Java API. +
Sure, https://jcp.org/en/jsr/detail?id=160[JSR-160, JMX Remote API] also provides a
Java based remote access to MBeans and one might wonder about
the benefits of another Jolokia Java binding. There are several,
though:

* It provides a typeless access to remote MBeans. The big
advantage is that for any non-OpenMBean access to custom typed
objects is still possible without having the type information
locally in the classpath.
* Jolokia can be used in scenarios where JSR-160 connectors can not
be used. I.e. in firewall secured environments it is much easier
to get through to a Jolokia Agent using HTTP than to a JSR-160 connector
using RMI as the transport protocol.
* _Remoteness_ is explicit in this API instead
of JSR-160 connector's seeked _transparent
remoteness_. RMI has some arguable conceptual
advantages, but hiding all the remote aspects proved to have quite
some disadvantages when it comes to the programming
model. Explicit awareness of a 'heavy-weight' remote call is
better than false transparency in order to know the price tag.

The Java client library follows a strict request-response
paradigm, much like the underlying HTTP. It uses generics heavily
and can be centered around three classes:

* `org.jolokia.client.JolokiaClient` is the client side class, which
has various variants of an `execute()` methods for
sending requests.
* These methods take one or more
`org.jolokia.client.request.JolokiaRequest` objects as arguments and
* return one or more `org.jolokia.client.request.JolokiaResponse` objects as a result.

=== JolokiaClient SPI

Since the initial Jolokia release https://github.com/jolokia/jolokia/commits/v0.80/[in 2010,role=externalLink,window=_blank], Jolokia
Client was implemented using https://hc.apache.org/httpcomponents-client-4.5.x/index.html[Apache HttpClient 4,role=externalLink,window=_blank]. +
This gives us 4 external dependencies: HttpClient4, HttpCore4, Commons Codec and Commons Logging.

https://openjdk.org/jeps/321[JEP 321,role=externalLink,window=_blank] introduced real HTTP Client API available in the JDK itself.
`java.net.HttpURLConnection` was not suitable for more serious scenarios.

https://github.com/jolokia/jolokia/issues/565[jolokia#565] was created in 2023, but it took a while to find a way to use JDK HTTP Client in Jolokia. While we _could_ consider Apache HttpClient4 as deprecated and move entirely to JDK HTTP Client, it turned out that it's possible to support both. +
And more.

Jolokia 2.4.0 introduced a breaking API change (violating a bit the https://semver.org/[Semantic Versioning guidelines,role=externalLink,window=_blank]), because we wanted to achieve few goals:

* rename `J4pClient` to `JolokiaClient`
* keep the Jolokia Client API as a set of `execute()` methods that accept _Jolokia request(s)_ and return _Jolokia response(s)_
* remove strict dependency of `JolokiaClient` on particular HTTP Client implementation (for example `org.apache.http.client.HttpClient` was used as an argument of `J4pClient` constructor and `J4pClientBuilder` was accepting `org.apache.http.client.CookieStore`)
* make `JolokiaClient` interface implementation-agnostic, but allow implementation-specific customization

Effectively we broke the API by renaming the class and removing the HttpClient4-specific arguments (renaming wouldn't happen without the removal).

The goals were achieved by:

* introducing `org.jolokia.client.spi.HttpClientSpi` SPI interface
* providing default implementation of this SPI interface based on JDK HTTP Client
* moving the implementation from Jolokia 2.3.0 to an SPI implementation based on https://hc.apache.org/httpcomponents-client-4.5.x/index.html[Apache HttpClient 4,role=externalLink,window=_blank]
* creating a new implementation based on https://hc.apache.org/httpcomponents-client-5.5.x/index.html[Apache HttpClient 5,role=externalLink,window=_blank]
* leveraging `/META-INF/services/org.jolokia.client.spi.HttpClientBuilder` https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/ServiceLoader.html[Service Loader,role=externalLink,window=_blank] interface.

Now, starting from Jolokia 2.4.0, users can create and call Jolokia Client, while the particular HTTP Client implementation
will be discovered automatically. And with default implementation (based on JDK HTTP Client) we no longer need _any_ external dependencies.

[#client-java-tutorial]
=== Tutorial

Here is a sample application using `JolokiaClient` to get the amount of used heap memory:

[,java]
----
import org.jolokia.client.JolokiaClient;
import org.jolokia.client.request.*;

public class MemoryDemo {
  public static void main(String[] args) {
    JolokiaClient client = new JolokiaClientBuilder().url("http://localhost:7778/jolokia")
        .user("jolokia")
        .password("jolokia")
        .build(); <1>
    JolokiaReadRequest request
        = new JolokiaReadRequest("java.lang:type=Memory", "HeapMemoryUsage"); <2>
    request.setPath("used"); <3>
    JolokiaReadResponse response = client.execute(request); <4>
    System.out.println("Memory used: " + response.getValue()); <5>
  }
}
----
<1> `JolokiaClient` object is used using a `JolokiaClientBuilder` builder
<2> A `JolokiaReadRequest` is created to specify an MBean name and its attribute to fetch
<3> A _path_ into the complex structure (here: `java.lang.management.MemoryUsage`) is specified
<4> The request is sent using the Jolokia Client and a related `JolokiaReadResponse` is obtained
<5> A value is printed from the response

In order to compile and run this example, we need only one library: `jolokia-client-java-{jolokia-version}.jar`. See link:/download.html[Download].

For Maven users, the following dependency is sufficient. It will use two transitive Jolokia dependencies:

* `jolokia-json-{jolokia-version}.jar` - for JSON serialization
* `jolokia-core-{jolokia-version}.jar` - for data conversion

[,xml,subs="attributes,verbatim"]
----
<dependency>
    <groupId>org.jolokia</groupId>
    <artifactId>jolokia-client-java</artifactId>
    <version>{jolokia-version}</version>
</dependency>
----

=== Using other HTTP Client implementation

If we want to use HTTP Client implementation from external library (instead of the one provided by the JDK itself), it's enough to add one of
these dependencies to the `CLASSPATH`:

.Use Apache Http Client 4
[,xml,subs="attributes,verbatim"]
----
<dependency>
    <groupId>org.jolokia</groupId>
    <artifactId>jolokia-client-java-httpclient4</artifactId>
    <version>{jolokia-version}</version>
</dependency>
----

.Use Apache Http Client 5
[,xml,subs="attributes,verbatim"]
----
<dependency>
    <groupId>org.jolokia</groupId>
    <artifactId>jolokia-client-java-httpclient5</artifactId>
    <version>{jolokia-version}</version>
</dependency>
----

[#client-client]
=== JolokiaClient and JavaClientBuilder API

`JolokiaClient` is the entry point for sending
requests to a remote Jolokia agent. It can be created in multiple
ways. For simple cases, public constructors are provided taking
the mandatory Jolokia agent URI and optionally an explicitly selected implementation
of `org.jolokia.client.spi.HttpClientSpi` SPI interface (to skip the autodiscovery mechanism).

The recommended style
is to use the `JolokiaClientBuilder`, though. This way, all
the parameters for HTTP communication can easily be set:

[,java]
----
JolokiaClient client = new JolokiaClientBuilder().url("http://localhost:7778/jolokia")
    .user("jolokia")
    .password("jolokia")
    .socketBufferSize(16384)
    .socketTimeout(5000)
    // ...
    .build();
----

The builder supports the following parameters with the given
defaults:

.JolokiaClient parameters
[cols="15,~,20"]
|===
|Parameter|Description|Default

|`url`
|The URL to the Jolokia agent. This is the only mandatory parameter. Can be specified as a String or a `java.net.URI` object.
|

|`user`
|Username when authentication is used. If not set, no
authentication is used. If set, `password`
must be set, too
|

|`password`
|Password used for authentication. Only used when
`user` is set.
|

|`target`
|A JMX JSR-160 ServiceURL which should be used by the agent
as the _real_ target. This parameter should
be set if the client is used for accessing the agent in
xref:proxy_mode.adoc[].
|

|`targetUser`
|The JSR-160 user to use when using the proxy mode. If not
given (and `target` is set), then no
authentication is used for JSR-160 communication.
|

|`targetPassword`
|JSR-160 Password to use for the proxy mode.
|

|`connectionTimeout`
|The timeout in milliseconds until a connection is
established. A timeout value of zero is interpreted as an
infinite timeout.
|`20000`

|`socketTimeout`
|Defines the socket timeout (`SO_TIMEOUT`) in milliseconds,
which is the timeout for waiting for data  or, put differently,
a maximum period inactivity between two consecutive data packets.
A timeout value of zero is interpreted as an infinite timeout.
|`0`

|`pooledConnection`
|Specifies, that the underlying HttpClient should use pooled
connection manager, which is thread safe and can service
connection requests from multiples threads
simultaneously. This is important if the
`JolokiaClient` is to be used in a multi
threaded context. The size of the pool is restricted by the
parameter `maxTotalConnection`.
`ThreadSafeClientConnManager` is the
underlying connection manager. Pooled connections are the
default.
|

|`singleConnection`
|Specifies that single connection should be used which
maintains only one active connection at a time.  Even though
`JolokiaClient` is still thread-safe it
ought to be used by one execution thread only. The
underlying connection manager is
`SingleClientConnManager` Pooled
connections are the default.
|

|`maxTotalConnections`
|Defines the number of total connections to be pooled. It
is only used when `pooledConnection` is
used.
|`20`

|`defaultMaxConnectionsPerRoute`
|Defines the number of total connections per route. It
is only used when `pooledConnection` is
used.
|`20`

|`maxConnectionPoolTimeout`
|Defines the timeout for waiting to obtain a connection
from the pool. This parameter is only used when
`pooledConnections` are used.
|`500`

|`contentCharset`
|Defines the charset to be used per default for encoding
content body.
|`ISO-8859-1`

|`expectContinue`
|Activates `Expect: 100-Continue` handshake
for the entity enclosing methods.  The purpose of the
`Expect: 100-Continue` handshake to allow a
client that is sending a request message with a request body
to determine if the origin server is willing to accept the
request (based on the request headers) before the client
sends the request body.  The use of the `Expect:
100-continue` handshake can result in noticeable
performance improvement for entity enclosing requests that
require the target server's authentication.
|`true`

|`tcpNoDelay`
|Determines whether Nagle's algorithm is to be used. The
Nagle's algorithm tries to conserve bandwidth by minimizing
the number of segments that are sent. When applications wish
to decrease network latency and increase performance, they
can disable Nagle's algorithm (that is enable
`TCP_NODELAY`). Data will be sent
earlier, at the cost of an increase in bandwidth
consumption.
|true

|`socketBufferSize`
|Determines the size of the internal socket buffer in bytes
used to buffer data while receiving and transmitting HTTP
messages.
|`8192`

|`proxy`
|Determines http proxy server. It can be defined as
`\http://user:password@host:port`. _user_ and
_password_ are optional.
|

|`useProxyFromEnvironment`
|Set the proxy for this client based on `http_proxy` system environment variable.
Expect formats are `\http://user:pass@host:port` or `\http://host:port`
Example: `\http://tom:sEcReT@my.proxy.com:8080`
|

|`responseExtractor`
|A response objectAccessor can be used for hooking into the JSON
deserialization process when a JSON response is converted
into a `JolokiaResponse` object. By
default, the received JSON object is examined for a status
code of 200 and only then creates a response
object. Otherwise an exception is thrown. An objectAccessor is
specified by the interface
`JolokiaResponseExtractor`. Beside the
default objectAccessor, an alternate objectAccessor
`ValidatingResponseExtractor` can be
used, which instead of throwing an exception returns a
`null` object when the response has a status of
404. An objectAccessor can be specified as extra argument to the
execute method, too.
|`org.jolokia.client.response.ValidatingResponseExtractor`

|`defaultHttpHeaders`
|A map of default HTTP headers that should be sent with Jolokia requests.
|

|`keystore`
|A keystore with client credentials to be used with HTTPS connections. The keystore
can be specified either as `java.nio.file.Path` or `java.security.KeyStore`
|

|`keystorePassword`
|Password to the keystore
|

|`keyPassword`
|Password to the Client key inside the keystore
|

|`truststore`
|A truststore with server certificates to be used with HTTPS connections. The truststore
can be specified either as `java.nio.file.Path` or `java.security.KeyStore`
|

|`truststorePassword`
|Password to the truststore
|

|`protocolVersion`
|TLS protocol version to be used with HTTPS connections. When this option is not set,
SSL configuration won't be used. We can use for example `TLSv1.3`.
|
|===

The `JolokiaClient` provides various variants
of a `execute()` method, which take
either one single request or a list of requests. For a single
request, the preferred HTTP method (GET or POST) can be
specified optionally. The `List<R>`
argument type can be used only for a homogeneous bulk request,
i.e. for multiple requests of the same time. Otherwise an
untyped list must be used.

Each request can be tuned by giving a map of processing options
along with their values to the `execute()`
method. The possible options are specified using `org.jolokia.client.JolokiaQueryParameter` enum and are shown in the below table:
<<client-java-queryopts>>.

[#client-java-queryopts]
.JolokiaClient query parameters
[cols="20,~"]
|===
|J4pQueryParameter enum|Description

|`MAX_DEPTH`
|Maximum traversal depth for serialization of complex
objects. Use this with a "list" request to restrict the
depth of the returned meta data tree.

|`MAX_COLLECTION_SIZE`
|Maximum size of collections returned during serialization.
If larger, a collection is truncated to this size.

|`MAX_OBJECTS`
|Maximum number of objects returned in the response's value.

|`SERIALIZE_LONG`
|An option about how to serialize `long` values. We have an option to use `number` or `string`.
This is more relevant for JavaScript, where the maximum value of a `long` type is different than in Java.

|`IGNORE_ERRORS`
|Option for ignoring errors during JMX operations and JSON
serialization.  This works only for certain operations like
pattern reads and should be either `true`
or `false`.

|`INCLUDE_STACKTRACE`
|Whether to include a stack trace in the response when an
error occurs.  The allowed values are
`true` for inclusion,
`false` if no stacktrace should be
included or `runtime` if only
``RuntimeException``s should be
included. Default is `true`.

|`SERIALIZE_EXCEPTION`
|Whether to include a JSON serialized version of the
exception. If set to `true`, the exception
is added under the key `error_value` in
the response. Default is `false`.

|`CANONICAL_NAMING`
|Whether property keys of `ObjectNames`
should be ordered in the canonical way or in the way that
they are created. The allowed values are either
`true` in which case the canonical key
order (== alphabetical sorted) is used or
`false` for getting the keys as
registered. Default is `true`

|`MIME_TYPE`
|Which MIME type to use with the response. only `text/plain` and `application/json` are supported.
This is not very important for the Java Client.

|`INCLUDE_REQUEST`
|Whether the response object should contain related request object. +
This option may be configured globally and overridden at request time.
When `false`, bulk responses have to be correlated with requests by matching
the requests using index number - responses come in the same order as requests. +
*Available since Jolokia 2.1.0*

|`LIST_KEYS`
|Whether to enable `org.jolokia.service.jmx.handler.list.ListKeysDataUpdater`, so the object names are split
into `key=value` pairs in the response

|`IF_MODIFIED_SINCE`
|Can be specified as milliseconds of the UNIX epoch for `list`
requests. If there were no changes after this timestamp in the
registered MBeans, a response with HTTP 304 return code is returned.

|`LIST_CACHE`
|Whether to use optimized version of the `list` response. It is _critical_ for the scenarios where the
Jolokia Agent has access to a lot of different MBeans of the same MBean interface. +
*Available since Jolokia 2.1.0*

|`LIST_INTERFACES`
|Whether the `list` response should add information about all the interfaces implemented by MBeans. This options was added to support `javax.management.MBeanServerConnection.isInstanceOf()` method in `jolokia-client-jmx-adapter` +
*Available since Jolokia 2.5.0*

|`OPEN_TYPES`
|Whether the `list` response should return information about ``javax.management.openmbean.OpenType``s used by
the MBeans. This allows much better insight into the complex data structures used by the MBeans. +
*Available since Jolokia 2.5.0*
|===

=== Implementation specific configuration

Because Jolokia Client supports now (since version 2.5.0) 3 different implementations, we've added a way to configure
implementation-specific details. For example the connection pool can be configured for Apache HttpClient using Java API, but
for JDK HTTP Client, system properties are used.

We can pass a _customizer_ to `org.jolokia.client.JolokiaClientBuilder` and here's an example of calling Apache HttpClient5
specific methods when configuring Jolokia Client. We can also grab an instance of actual implementation:

[,java]
----
import org.apache.hc.client5.http.classic.HttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClientBuilder;
import org.jolokia.client.JolokiaClient;
import org.jolokia.client.JolokiaClientBuilder;

public class App {

  public static void main(String[] args) throws Exception {
    JolokiaClient client = new JolokiaClientBuilder().url("http://localhost:8080/jolokia")
        .withCustomizer(HttpClientBuilder.class, (HttpClientBuilder builder) -> {
            builder.setUserAgent("My Client based on HttpClient 5");
            called[0] = true;
        }).build();
    HttpClient realClient = client.getHttpClient(HttpClient.class);
  }
}
----

[#client-java-requests]
=== Request types

For each request type a dedicated request object is provided
which all are subclasses from
`JolokiaRequest`. For all requests it can be
specified which HTTP method is to be used by setting the
property `preferredHttpMethod` to either
`GET` or `POST`.

Each request type has a corresponding response type which used
for the return values of the
`JolokiaClient.execute()`.

The constructor of each kind of request can take a
`JolokiaTargetConfig` as argument for using a
request in xref:proxy_mode.adoc[]. This
configurational object holds the JMX service url and
(optionally) credentials for JSR-160 authentication. When
given, this proxy target specification overrides any default
proxy configuration set during the initialization of the
`JolokiaClient`.

`JolokiaReadRequest` and `JolokiaReadResponse`:: `JolokiaReadRequest` is a read request to
get one or more attributes from one or more MBeans within
a single request. Various constructor variants can be used
to specify one or more attributes along with the
ObjectName (which can be a pattern). A
`path` can be set as property for
specifying an _inner path_, too.
+
`JolokiaReadResponse` is the
corresponding response type and allows typed access to the
fetched value for a single attribute fetch or to multiple
values for a multi attribute read. In the latter case, the
found object and attributes names can be retrieved as
well.
+
For more information on fetching the value of multiple
attributes and multiple MBeans at once, please refer to
xref:protocol/read.adoc[Reading attributes (read)] or the Javadoc of
`JolokiaReadResponse`.

`JolokiaWriteRequest` and `JolokiaWriteResponse`:: A `JolokiaWriteRequest` is used to set
the value of an MBean attribute. Beside the mandatory
object and attribute name the value must be give in the
constructor as well. Optionally a `path`
can be provided, too. Only certain types for the given
value can be serialized properly for calling the Jolokia
agent as described in xref:jolokia_protocol.adoc#serialization-request[Request parameter serialization].
+
The old value is returned as ``JolokiaWriteResponse``'s value.

`JolokiaExecRequest` and `JolokiaExecResponse`:: ``JolokiaExecRequest``'s are used for
executing operation on MBeans. The constructor takes as
mandatory arguments the MBean's object name, the operation
name and any arguments required by the operation. Only
certain types for the given arguments can be serialized
properly for calling the Jolokia agent as described in
xref:jolokia_protocol.adoc#serialization-request[Request parameter serialization].
+
The returned `JolokiaExecResponse`
contains the return value of the operation called.

`JolokiaSearchRequest` and `JolokiaSearchResponse`:: A `JolokiaSearchRequest` contains a
valid single MBean object name pattern which is used for
searching MBeans.
+
The `JolokiaSearchResponse` holds a
list of found object names.

`JolokiaListRequest` and `JolokiaListResponse`:: For obtaining meta data on MBeans a
`JolokiaListRequest` should be used. It
can be used with a _inner path_ to
obtain only a subtree of the response, otherwise the whole
tree as described in xref:jolokia_protocol.adoc#response-list[List response] is
returned. With the query parameter
`maxDepth` can be used to restrict the
depth of returned tree.
+
The single value of a
`JolokiaListResponse` is a tree (or
subtree) as a JSON object, which has the format described
in xref:jolokia_protocol.adoc#response-list[List response].

`JolokiaVersionRequest` and `JolokiaVersionResponse`:: A `JolokiaVersionRequest` request the
Jolokia agent's version information and takes no
argument.
+
The `JolokiaVersionResponse` returns the
agent's version (`agentVersion`), the
protocol version (`protocolVersion`), the
application server product name
(`product`), the vendor name
(`vendor`) and any extra info
(`extraInfo`) specific to the platform
the Jolokia is running on.

[#client-java-exceptions]
=== Exceptions

In case of an error when executing a request a
`JolokiaException` or one its subclass is
thrown.

`JolokiaConnectException`:: Exception thrown when the connection to the server
fails. It contains the original
`java.net.ConnectException` as nested value.

`JolokiaTimeoutException`:: Exception thrown in case of an timeout. The nested
exception depends on the HTTP Client implementation used, but should be an instance of
`java.io.IOException`

`JolokiaHttpException`:: Exception thrown in when the HTTP response is not delivered using
HTTP status code 200. In such case, the response does not contain JSON body.

`JolokiaRemoteException`:: Generic exception thrown when an exception occurred on the
remote side. This is the case when the JSON response
obtained is an error response as described in
xref:jolokia_protocol.adoc#responses[Responses]. The error type, error value, the
status, the request leading to this error and the remote
stacktrace as string) can be obtained from this exception.

`JolokiaBulkRemoteException`:: Exception thrown when a bulk request fails on the remote
side. This contains a mixed list which contains the
`JolokiaRemoteException` occurred as well
as the `JolokiaResponse` objects for the
requests, which succeeded. The list obtained by
`getResults()` contains these
objects in the same order as the list of requests given to
`execute`. All responses and remote
exceptions can also be obtained separately in homogeneous
lists.

`JolokiaException`:: Base exception thrown, when no other exception fits,
i.e. when the exception happened on the client side. The
original exception is contained as nested exception.
