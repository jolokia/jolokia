<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Extending Jolokia :: Jolokia</title>
    <link rel="canonical" href="https://jolokia.org/manual/extensions.html">
    <link rel="prev" href="jolokia_mbeans.html">
    <link rel="next" href="clients.html">
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../_/css/site.css">
    <link rel="stylesheet" href="../_/css/jolokia.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://jolokia.org">Jolokia</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="manual" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="index.html">Jolokia Manual</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="architecture.html">Architecture</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="jmx_guide.html">JMX Guide</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="jmx_remote_guide.html">JMX Remote Guide</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="agents.html">Agents</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="security.html">Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="proxy_mode.html">Proxy Mode</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="jolokia_protocol.html">Jolokia Protocol</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="jolokia_mbeans.html">Jolokia MBeans</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="extensions.html">Extending Jolokia</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="clients.html">Clients</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="jolokia_jmx.html">JMX Support</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="spring.html">Spring Support</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Jolokia Manual</span>
    <span class="version"></span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="index.html">Jolokia Manual</a></div>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Jolokia Manual</a></li>
    <li><a href="extensions.html">Extending Jolokia</a></li>
  </ul>
</nav>
<div class="edit-this-page"><a href="https://github.com/jolokia/jolokia/tree/main/src/documentation/manual/modules/ROOT/pages/extensions.adoc">Help improving this page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Extending Jolokia</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In Jolokia 1.x, the necessary functions were provided by <em>services</em> directly instantiated by these <em>agent implementations</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.jolokia.http.AgentServlet</code> (WAR)</p>
</li>
<li>
<p><code>org.jolokia.osgi.servlet.JolokiaServlet</code> (OSGi)</p>
</li>
<li>
<p><code>org.jolokia.jvmagent.JolokiaServer</code> (JVM)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Only implementations of detectors and simplifiers were detected respectively from:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>META-INF/detectors[-default]</code> (implementations of <code>org.jolokia.detector.ServerDetector</code>)</p>
</li>
<li>
<p><code>META-INF/simplifiers[-default]</code> (implementations of <code>org.jolokia.converter.json.Extractor</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In Jolokia 2 there&#8217;s another resource checked - <code>services[-default]</code> and additionally the declaration files were moved to more specific location:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>META-INF/jolokia/detectors[-default]</code> (implementations of <code>org.jolokia.server.core.detector.ServerDetector</code>)</p>
</li>
<li>
<p><code>META-INF/jolokia/simplifiers[-default]</code> (implementations of <code>org.jolokia.converter.json.ObjectAccessor</code>)</p>
</li>
<li>
<p><code>META-INF/jolokia/services[-default]</code> (implementations of <code>org.jolokia.server.core.service.api.JolokiaService</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, what was a dedicated <code>org.jolokia.history.HistoryStore</code> in Jolokia 1, used directly by <code>org.jolokia.backend.BackendManager</code> is now used by <code>org.jolokia.service.history.HistoryMBeanRequestInterceptor</code> <em>Jolokia service</em> declared in <code>META-INF/jolokia/services-default</code> resource in <code>org.jolokia:jolokia-service-history</code> module.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_note_about_service_loader_approach"><a class="anchor" href="#_a_note_about_service_loader_approach"></a>A note about <em>Service Loader</em> approach</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>META-INF/jolokia/services</code> is a bit similar approach to Java standard <code>java.util.ServiceLoader</code> API, where the services are <em>declared</em> in <code>META-INF/services/interface-name</code>.</p>
</div>
<div class="paragraph">
<p>The most important aspect is that the instantiation of such services is performed by the JDK (or Jolokia) itself and if 3rd party applications use more sophisticated <em>service registries</em> (like CDI or Spring DI), then we can&#8217;t avoid static fields&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>So if a Jolokia service extension needs to use other dependencies, it&#8217;s up to the application to provide necessary integration. Static fields is the easiest (but not a super-clean) option.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extension_points_in_jolokia_2"><a class="anchor" href="#_extension_points_in_jolokia_2"></a>Extension points in Jolokia 2</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jolokia, when starting, uses <code>java.lang.ClassLoader.getResources</code> call to find various locations of the above service declaration resources. This allows 3rd party libraries to simply add a classpath library containing relevant resource and declare class names to be instantiated and used by Jolokia.</p>
</div>
<div class="paragraph">
<p>The format of the extension file <code>META-INF/jolokia/services[-default]</code> is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs"># comment
[!]fully.qualified.class.name[,order]</code></pre>
</div>
</div>
<div class="paragraph">
<p>if line is not a comment, it is treated as <em>service entry</em>. There are two types of entries:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>remove entry</em> - if a line starts with <code>!</code> (exclamation mark), we can declare a fully qualified name of a service declared in another (most probably Jolokia&#8217;s own) service file, so we can <em>disable</em> usage and instantiation of given service. For example, we can remove history service with <code>!org.jolokia.service.history.HistoryMBeanRequestInterceptor</code> even if <code>org.jolokia:jolokia-service-history</code> is available on classpath</p>
</li>
<li>
<p><em>service entry</em> - if a line doesn&#8217;t start with <code>!</code>, a class is instantiated using one of two possible constructors:</p>
<div class="ulist">
<ul>
<li>
<p>empty constructor</p>
</li>
<li>
<p>a constructor accepting integer value which is treated as "order" of the service. The value to pass is read after the comma in <em>service entry</em>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Service order is used to prioritize the services of the same interface - the lower the number, the higher the priority (preference). Default order is <code>100</code>.</p>
</div>
<div class="paragraph">
<p>In the following sections we describe various services that may be declared by 3rd party libraries.</p>
</div>
<div class="sect2">
<h3 id="_mbean_info_cache"><a class="anchor" href="#_mbean_info_cache"></a>MBeanInfo cache</h3>
<div class="paragraph">
<p>Jolokia is first and foremost a <em>JMX protocol adaptor</em> (see <a href="architecture.html" class="xref page">Architecture</a>). This means that whatever is registered in local (or remote) MBeanServer, is accessible using "JSON over HTTP".</p>
</div>
<div class="paragraph">
<p>While this is a straightforward statement, the reality may be harsh sometimes. For example in <a href="https://activemq.apache.org/components/artemis/" class="externalLink" target="_blank" rel="noopener">Apache ActiveMQ Artemis</a> broker, if you create, say, 10,000 queues, JVM ends up with additional 20,000 MBeans registered - a pair if these MBeans for single queue:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>address="queue-name",broker="0.0.0.0",component=addresses</code></p>
</li>
<li>
<p><code>address="queue-name",broker="0.0.0.0",component=addresses,queue="queue-name",routing-type="anycast",subcomponent=queues</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The first Mbean is for <code>org.apache.activemq.artemis.core.management.impl.AddressControlImpl</code> and second one is for <code>org.apache.activemq.artemis.core.management.impl.QueueControlImpl</code>. What&#8217;s more, the JSON map for <code>javax.management.MBeanInfo</code> of these MBeans is huge (over hundred attributes and operations for each pair). Multiplying it by 10K, Jolokia has to return 234MB of JSON data.</p>
</div>
<div class="paragraph">
<p>To address this problem, Jolokia 2.1.0 introduces an <em>optimized list operation</em>, where instead of simple (but big) structure of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>domain:
  mbean:
    op:
    attr:
    notif:
    class:
    desc:
  ...
...</pre>
</div>
</div>
<div class="paragraph">
<p>we provide a <em>smarter</em> (a bit more complex, but much smaller) structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>"domains":
  domain:
    mbean: cache-key
    ...
  ...
"cache":
  cache-key:
    op:
    attr:
    notif:
    class:
    desc:
  ...</pre>
</div>
</div>
<div class="paragraph">
<p>Basically instead of duplicating the same JSON representation of <code>javax.management.MBeanInfo</code> over and over again for the same MBeans (2x10,000 times for 10,000 Artemis queues), we do some optimization here:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Jolokia calls <code>javax.management.MBeanServerConnection.queryMBeans()</code> normally, getting a set of <code>javax.management.ObjectInstance</code> objects.</p>
</li>
<li>
<p>Each <code>ObjectInstance</code> carries an <code>ObjectName</code> and <code>className</code>.</p>
</li>
<li>
<p>Without any optimization, <code>ObjectName</code> is used in <code>javax.management.MBeanServerConnection.getMBeanInfo()</code> call and result is the serialized using <code>org.jolokia.server.core.service.api.DataUpdater</code> services.</p>
</li>
<li>
<p>However, both <code>ObjectName</code> and <code>ObjectInstance</code>'s class can be used to obtain a <em>key</em> (or a <em>hint</em>) which determines that some MBeans may <em>share</em> its <code>javax.management.MBeanInfo</code> with other MBeans.</p>
</li>
<li>
<p>When a non-null key for an MBean is obtained, its MBeanInfo is cached under <code>"cache"</code> field and related MBean under <code>"domains"</code> field simply points to cached JSON data of <code>javax.management.MBeanInfo</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In order to use such variant of <code>list()</code> operation, a new processing request parameter has to be specified. This is done using <code>listCache=true</code> parameter (defaults to <code>false</code> for compatibility reasons).</p>
</div>
<div class="paragraph">
<p>When optimization is enabled, Jolokia uses <code>org.jolokia.service.jmx.api.CacheKeyProvider</code> services. if <code>determineKey(ObjectInstance)</code> method returns non-null key, it is used to share common JSON MBean information with other MBeans that produce the same cache key.</p>
</div>
<div class="paragraph">
<p>Jolokia itself provides optimization only for few fundamental MBeans:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.lang:type=MemoryPool,name=*</code> (class is <code>sun.management.MemoryPoolImpl</code>) - there are 8 instances by default in standard JVM (without any sophisticated memory settings)</p>
</li>
<li>
<p><code>java.lang:type=MemoryManager,name=*</code> (class is <code>sun.management.MemoryManagerImpl</code>) - there are 2 instances by default in standard JVM</p>
</li>
<li>
<p><code>java.nio:type=BufferPool,name=*</code> (class is <code>sun.management.ManagementFactoryHelper$1</code>) - there are 3 instances by default in standard JVM</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>With these 3 optimizations, instead of this response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">"value": {
  "java.lang": {
    "name=G1 Survivor Space,type=MemoryPool": {
      "op": {
        "resetPeakUsage": {
          "args": [],
          "ret": "void",
          "desc": "resetPeakUsage"
        }
      },
      "attr": {
        "Usage": {
          "rw": false,
          "type": "javax.management.openmbean.CompositeData",
          "desc": "Usage"
        },
        ...
    "name=Metaspace,type=MemoryPool": {
      "op": {
        "resetPeakUsage": {
          "args": [],
          "ret": "void",
          "desc": "resetPeakUsage"
        }
      },
      "attr": {
        "Usage": {
          "rw": false,
          "type": "javax.management.openmbean.CompositeData",
          "desc": "Usage"
        },
        ...
    "name=G1 Eden Space,type=MemoryPool": {
      "op": {
        "resetPeakUsage": {
          "args": [],
          "ret": "void",
          "desc": "resetPeakUsage"
        }
      },
      ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>We get this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">"value": {
  "cache": {
    "java.lang:MemoryPool": {
      "op": {
        "resetPeakUsage": {
          "args": [],
          "ret": "void",
          "desc": "resetPeakUsage"
        }
      },
      "attr": {
        "Usage": {
          "rw": false,
          "type": "javax.management.openmbean.CompositeData",
          "desc": "Usage"
        },
        ...
    "java.nio:BufferPool": {
      "attr": {
        "TotalCapacity": {
          "rw": false,
          "type": "long",
          "desc": "TotalCapacity"
        },
        ...
      }
    }
  }
  "domains": {
    "java.lang": {
      "name=G1 Survivor Space,type=MemoryPool": "java.lang:MemoryPool",
      "name=Metaspace,type=MemoryPool": "java.lang:MemoryPool",
      "name=G1 Eden Space,type=MemoryPool": "java.lang:MemoryPool",
      "name=CodeCacheManager,type=MemoryManager": "java.lang:MemoryManager",
      "name=CodeHeap 'non-nmethods',type=MemoryPool": "java.lang:MemoryPool",
      "name=G1 Old Gen,type=MemoryPool": "java.lang:MemoryPool",
      "name=Compressed Class Space,type=MemoryPool": "java.lang:MemoryPool",
      "name=CodeHeap 'non-profiled nmethods',type=MemoryPool": "java.lang:MemoryPool",
      "name=CodeHeap 'profiled nmethods',type=MemoryPool": "java.lang:MemoryPool",
      "name=Metaspace Manager,type=MemoryManager": "java.lang:MemoryManager",
      ...
    },
    "java.nio": {
      "name=direct,type=BufferPool": "java.nio:BufferPool",
      "name=mapped,type=BufferPool": "java.nio:BufferPool",
      "name=mapped - 'non-volatile memory',type=BufferPool": "java.nio:BufferPool"
    },
    ...</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>The MBeans for which we don&#8217;t determine any <em>cache key</em> are included under <code>"domains"/&lt;domain&gt;/&lt;key-list-of-MBean&gt;</code> normally.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>We can imagine Artemis adding a cache key provider for <code>org.apache.activemq.artemis</code> domain and MBeans with <code>component=addresses</code> key. There&#8217;s a lot of optimization to be <em>declared</em> in <a href="https://camel.apache.org/" class="externalLink" target="_blank" rel="noopener">Apache Camel</a> too.</p>
</div>
<div class="paragraph">
<p>See <a href="https://github.com/jolokia/jolokia/discussions/705" class="externalLink" target="_blank" rel="noopener">jolokia/jolokia#705</a> for the rationale behind new Jolokia protocol version.</p>
</div>
</div>
<div class="sect2">
<h3 id="_data_updaters"><a class="anchor" href="#_data_updaters"></a>Data updaters</h3>
<div class="paragraph">
<p>Previous section described services that may affect the structure of <em>entire</em> <code>list()</code> response. This section is about services that affect single MBeanInfo of any MBean.</p>
</div>
<div class="paragraph">
<p><code>org.jolokia.server.core.service.api.DataUpdater</code> is an interface used by the <code>list()</code> operation. Normally when invoking <a href="jolokia_protocol.html#list" class="xref page">list</a> operation, we get a JSON tree with a structure like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "&lt;domain of ObjectName&gt;": {
    "&lt;prop list from ObjectName&gt;": {
      "attr": ...,
      "op": ...,
      "notif": ...,
      "class": ...,
      "desc": ...
    },
    ...
  },
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such JSON contains information obtained from <code>javax.management.MBeanInfo</code> objects and describes what is known about the registered MBean from the perspective of <code>javax.management.MBeanServer</code>.</p>
</div>
<div class="paragraph">
<p>Built-in implementations of <code>org.jolokia.server.core.service.api.DataUpdater</code> interface simply add these fields (<code>attr</code>, <code>op</code>, &#8230;&#8203;) to the JSON data.</p>
</div>
<div class="paragraph">
<p>However, there may be scenarios where for each MBean we need some additional data - for example the security roles assigned to the given MBean (to implement a form of Role-Based Access Control (RBAC)). Jolokia isn&#8217;t aware of the way an application implements security mechanisms, but should allow for any extension of the basic MBean data.</p>
</div>
<div class="paragraph">
<p>We can provide an extension module, add it to the CLASSPATH and declare additional <em>data updaters</em> in <code>META-INF/jolokia/services</code>. <code>org.jolokia.server.core.service.api.DataUpdater</code> is already an implementation of <code>org.jolokia.server.core.service.api.JolokiaService</code> and it&#8217;s an abstract class we can extend. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.example;

public class MyUpdater extends org.jolokia.server.core.service.api.DataUpdater {

    public MyUpdater() {
        super(100);
    }

    @Override
    public String getKey() {
        return "time";
    }

    @Override
    public JSONObject extractData(ObjectName pObjectName, MBeanInfo pMBeanInfo, String pFilter) {
        JSONObject json = new JSONObject();
        json.put("now", System.currentTimeMillis());
        return json;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This <em>updater</em> adds <code>time</code> field to the JSON info for an MBean with current timestamp, but we can imagine any other kind of <em>updater</em>. It is declared using the below line in <code>META-INF/jolokia/services</code> resource:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>com.example.MyUpdater</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>It is recommended for advanced 3rd party extensions to implement both <em>cache key provider</em> and <em>data updater</em>. We can imagine for Artemis broker that some queues are more restricted than others, so their serialized MBean info may contain different custom data then other queues, so they should produce different <em>cache key</em>.</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_listkeysdataupdater"><a class="anchor" href="#_listkeysdataupdater"></a><code>ListKeysDataUpdater</code></h4>
<div class="paragraph">
<p>Since 2.1.0, Jolokia provides optional implementation of <code>org.jolokia.server.core.service.api.DataUpdater</code> service which can be enabled using <code>listKeys</code> processing parameter. When it is set (at request time) to <code>true</code>, in addition to standard <code>attr</code>, <code>op</code>, <code>notif</code>, <code>class</code> and <code>desc</code> fields of serialized MBeanInfo, we get another field <code>keys</code>.<br>
It contains a map of keys obtained from the <code>ObjectName</code> itself using <code>javax.management.ObjectName.getKeyPropertyList()</code> method.</p>
</div>
<div class="paragraph">
<p>With this parameter we can get the below response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "type": "list"
  },
  "value": {
    "java.lang": {
      "name=CodeHeap 'non-nmethods',type=MemoryPool": {
        "keys": {
          "name": "CodeHeap 'non-nmethods'",
          "type": "MemoryPool"
        },
        "op": ...,
        "attr": ...
        ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>This may be used to save time parsing object key-list like <code>name=CodeHeap 'non-nmethods',type=MemoryPool</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_jolokia_server_detectors"><a class="anchor" href="#_jolokia_server_detectors"></a>Jolokia Server Detectors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jolokia used <code>org.jolokia.server.core.detector.ServerDetector</code> interface for a long time. Jolokia included server
detectors for several products like ActiveMQ, JBoss, WebLogic, WebSphere and other. Product-specific detectors
provide:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>special <code>javax.management.MBeanServerConnection</code> instances for MBean servers not detected by <code>java.lang.management.ManagementFactory</code></p>
</li>
<li>
<p><code>org.jolokia.server.core.service.request.RequestInterceptor</code> services to handle the requests in product-specific way (there is only one Glassfish-specific interceptor)</p>
</li>
<li>
<p><code>org.jolokia.server.core.service.api.ServerHandle</code> with product-specific information (name, version)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/jolokia/jolokia/issues/258" class="externalLink" target="_blank" rel="noopener">jolokia#258</a> added new responsibility to
the server detector, so Jolokia JVM agent could actively wait for some conditions before proceeding. This is used
to wait for some classes or services to be available. The detectors can wait and additionally return &#8230;&#8203; a <code>java.lang.ClassLoader</code> instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ServerDetector extends JolokiaService&lt;ServerDetector&gt;, Comparable&lt;ServerDetector&gt; {

    ...
    ClassLoader jvmAgentStartup(Instrumentation instrumentation);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This may sound complex and unnecessary, but the concept is quite clear:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>let the detectors wait for initialization</p>
</li>
<li>
<p>if the detector returns a <code>ClassLoader</code>, this loader will then ne used by Jolokia service to perform initialization (including looking up additional services).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is important when using Jolokia JVM Agent in containers like Tomcat or Artemis, where the application (boot) classpath usually consists
of some kind of <em>bootstrap</em> JARs which role is only to create a <em>full</em> <code>ClassLoader</code> with JARs and resources from <code>lib/</code> directory (or other).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>see Tomcat&#8217;s <code>${catalina.home}/lib</code> directory</p>
</li>
<li>
<p>see Artemis' <code>${artemis.instance}/lib</code> and <code>${artemis.home}/lib</code> directories</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And recently in Jolokia 2.1.2, with <a href="https://github.com/jolokia/jolokia/issues/754" class="externalLink" target="_blank" rel="noopener">jolokia#754</a> we&#8217;ve introduced
the concept of a <code>org.jolokia.server.core.service.container.ContainerLocator</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface ContainerLocator extends JolokiaService&lt;ContainerLocator&gt; {

    /**
     * Returns an instance of a &lt;em&gt;runtime&lt;/em&gt; or &lt;em&gt;container&lt;/em&gt; specific class to be used by
     * a dedicated Jolokia service.
     *
     * @param clazz A class guard to ensure that the returned instance is of proper class
     * @return
     * @param &lt;T&gt;
     */
    &lt;T&gt; T locate(Class&lt;T&gt; clazz);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Currently only <code>org.jolokia.server.detector.misc.ArtemisDetector</code> returns special <code>ContainerLocator</code>, but this locator is
not used by Jolokia itself.</p>
</div>
<div class="paragraph">
<p>The role of this interface is to give access to server-specific services/interfaces/classes from other services - usually 3rd party libraries.
See the following <a href="#_jolokia_integration_project">Jolokia Integration project</a> section.</p>
</div>
<div class="paragraph">
<p>Jolokia itself should not depend on any special classes and interfaces from other projects. Note that classes like <code>org.jolokia.server.detector.misc.ArtemisDetector</code> may use reflection or other form of dynamic discovery, but there are no Maven dependencies on (in this case) Artemis.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_jolokia_integration_project"><a class="anchor" href="#_jolokia_integration_project"></a>Jolokia Integration project</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://github.com/jolokia/jolokia-integration" class="externalLink" target="_blank" rel="noopener">Jolokia Integration</a> is a special project built on the concepts mentioned in this chapter:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#_mbean_info_cache">MBeanInfo cache</a> and <a href="#_data_updaters">Data updaters</a> may be implemented by external services</p>
</li>
<li>
<p><a href="#_jolokia_server_detectors">Jolokia Server Detectors</a> may reflectively/dynamically make Jolokia aware of the environment where the Agent is running</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Specifically:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Jolokia should not statically (with Maven dependencies) depend on projects like Artemis or Tomcat</p>
</li>
<li>
<p>Projects like Artemis or Tomcat should not depend on Jolokia (when not needed)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Currently <a href="https://github.com/jolokia/jolokia-integration" class="externalLink" target="<em>blank">Jolokia Integration</a> should be treated as _technical preview</em> project, but it is <a href="https://issues.apache.org/jira/browse/ARTEMIS-5427" class="externalLink" target="_blank" rel="noopener">already actively used with Apache Artemis</a>.</p>
</div>
<div class="paragraph">
<p>As of the latest version 0.8.0, Jolokia-Integration provides two services:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.jolokia.integration.artemis.ArtemisCacheKeyProvider</code> - optimizes the JSON size for the MBeans which are known to come in huge amounts (like queues and addresses)</p>
</li>
<li>
<p><code>org.jolokia.integration.artemis.ArtemisDataUpdater</code> - adds <code>canInvoke</code> flag for each MBean, MBean operation and MBean attribute based on <a href="https://artemis.apache.org/components/artemis/documentation/latest/management.html#jmx-authorization-in-broker-xml" class="externalLink" target="_blank" rel="noopener">RBAC configuration provided by Artemis</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are plans to include similar integration with <a href="https://camel.apache.org/" class="externalLink" target="_blank" rel="noopener">Apache Camel</a>.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="jolokia_mbeans.html">Jolokia MBeans</a></span>
  <span class="next"><a href="clients.html">Clients</a></span>
</nav>
</article>
  </div>
<footer class="footer">
  This page was built using the Antora default UI. The source code for this UI is licensed under the terms of the MPL-2.0 license. | Copyright © 2010 -
  2025 Roland Huß
</footer>
<script id="site-script" src="../_/js/site.js" data-ui-root-path="../_"></script>
<script async src="../_/js/vendor/highlight.js"></script>
</main>
</div>
  </body>
</html>
