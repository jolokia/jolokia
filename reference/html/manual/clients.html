<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Clients :: Jolokia</title>
    <link rel="canonical" href="https://jolokia.org/manual/clients.html">
    <link rel="prev" href="extensions.html">
    <link rel="next" href="jolokia_jmx.html">
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../_/css/site.css">
    <link rel="stylesheet" href="../_/css/jolokia.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://jolokia.org">Jolokia</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="manual" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="index.html">Jolokia Manual</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="architecture.html">Architecture</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="jmx_guide.html">JMX Guide</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="jmx_remote_guide.html">JMX Remote Guide</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="agents.html">Agents</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="security.html">Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="proxy_mode.html">Proxy Mode</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="jolokia_protocol.html">Jolokia Protocol</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="jolokia_mbeans.html">Jolokia MBeans</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="extensions.html">Extending Jolokia</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="clients.html">Clients</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="jolokia_jmx.html">JMX Support</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="spring.html">Spring Support</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Jolokia Manual</span>
    <span class="version"></span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="index.html">Jolokia Manual</a></div>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Jolokia Manual</a></li>
    <li><a href="clients.html">Clients</a></li>
  </ul>
</nav>
<div class="edit-this-page"><a href="https://github.com/jolokia/jolokia/tree/main/src/documentation/manual/modules/ROOT/pages/clients.adoc">Help improving this page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Clients</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Three client implementations exists for Jolokia: Jmx4Perl, the
Perl binding (the grandmother of all clients ;-), a Java library
and a JavaScript library. This reference describes the client
bindings bundled with Jolokia. Information about Jmx4Perl can be found
<a href="https://metacpan.org/dist/jmx4perl" class="externalLink" target="_blank" rel="noopener">elsewhere</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="client-javascript"><a class="anchor" href="#client-javascript"></a>JavaScript Client Library</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Documentation for the previous version (pre-NPM, not based on TypeScript) of JavaScript library is available here: <a href="client/javascript-old.html" class="xref page">JavaScript Client Library (before ES modules)</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Notable difference from previous version (pre 2.1.0) are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The code is developed now using TypeScript language and processed using <a href="https://rollupjs.org/">Rollup JS</a> into ESM version (<code>jolokia.mjs</code> to be used with <code>import</code> statement) and UMD version (<code>jolokia.js</code> - to be used with browsers when not loading the script as <code>type="module"</code>)</p>
</li>
<li>
<p>There&#8217;s no dependency on <a href="https://jquery.com/">JQuery</a> anymore</p>
</li>
<li>
<p>For HTTP requests, we use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a>.</p>
</li>
<li>
<p>There&#8217;s no support for ancient <a href="https://en.wikipedia.org/wiki/JSONP">JSONP</a>. <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS</a> it the way to handle cross-origin requests.</p>
</li>
<li>
<p>Because Fetch API is used, there&#8217;s no direct support for <em>synchronous requests</em> - this can be achieved simply using <code>async</code> and <code>await</code></p>
</li>
<li>
<p>There was an <code>ajaxError</code> option to handle HTTP/connection errors, but it was used to configure jQuery&#8217;s <code>$.ajax</code> call. Now <code>Jolokia.request</code> in Promise mode returns a <code>Promise</code> object and we can handle <em>global errors</em> using <code>Promise.catch()</code> handler where the passed object is a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">Response</a> object.</p>
</li>
<li>
<p>In callback mode we can still pass <code>success</code> and <code>error</code> callbacks (to handle successfull and failed Jolokia responses - all delivered with HTTP 200 status code) and additionally we can pass <code>fetchError</code> (name was changed from <code>ajaxError</code>, because signature has changed as well) configuration option when creating new <code>Jolokia</code> object - this callback will be called with <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">Response</a> object to check for HTTP errors, etc. (when HTTP status is not <code>200</code>) and/or with an error thrown by <code>fetch()</code> API call.</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch#exceptions"><code>fetch()</code> call</a> may throw an exception (<code>DOMException</code> or <code>TypeError</code>) when networking error occurs or <code>fetch()</code> is configured in wrong way (for example with bad headers). Mind that it was a bit different with jQuery Ajax, where both HTTP error responses (like <code>404</code>) and networking errors where handled with single callback being called with <code>xhr</code> instance. After switching to <code>fetch()</code> API, these errors in promise mode have to be handled in different way:</p>
<div class="ulist">
<ul>
<li>
<p>networking and configuration errors can be handled by attaching a <code>.catch()</code> handler to <code>Jololokia.request()</code> returned promise. The error will be a <code>DOMException</code> or <code>TypeError</code></p>
</li>
<li>
<p>HTTP error responses (where status is different than <code>200</code>) can be handled by attaching a <code>.catch()</code> handler, where the passed object will be a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">Response</a>.</p>
</li>
<li>
<p>In callback mode, both the exception and failed <code>Response</code> objects can be passed to a callback configured with <code>fetchError</code> option.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>All methods of this library are available via the
<code>Jolokia</code> client object, which needs to be
instantiated up-front. In the following example a client object is
created and the used heap memory is requested synchronously via
the simple API. The agent is deployed within the same web archive
which also serves this script.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a sample code fragment that uses global <code>Jolokia</code> class which is used to create a <code>jolokia</code>
instance used to invoke simple (from <code>@jolokia.js/simple</code> package) <code>getAttribute()</code> operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">const jolokia = new Jolokia("/jolokia")
const value = await jolokia.getAttribute("java.lang:type=Memory", "HeapMemoryUsage", "used")
console.log("Heap Memory used: " + value)</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="js-installation"><a class="anchor" href="#js-installation"></a>Installation</h3>
<div class="paragraph">
<p>The Jolokia JavaScript library is distributed in the form of npm packages which should be used as standard JavaScript libraries. It&#8217;s out of scope of this documentation to describe all possible bundler setups which may be used, let&#8217;s simply focus on two <em>flavors</em> of these libraries.</p>
</div>
<div class="paragraph">
<p><code>package.json</code> for <code>jolokia.js</code> package contains this module-related section:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">"exports": {
  ".": {
    "types": "./dist/dts/jolokia.d.ts",
    "import": "./dist/jolokia.mjs",
    "default": "./src/jolokia.ts"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The recommended way to use this package is with JavaScript ES modules:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">import Jolokia from "jolokia.js"

const jolokia = new Jolokia("/jolokia")
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>However if there&#8217;s a need to use Jolokia JavaScript libraries directly, it&#8217;s always possible
to download relevant files (normal an minified) from <a href="/download.html">download page</a>.
Then we can refer to the scripts from HTML page:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;head&gt;
  &lt;script src="jolokia-2.5.0.min.js"&gt;&lt;/script&gt;
  &lt;script src="jolokia-simple-2.5.0.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Jolokia client is always created as an instance of
<code>Jolokia</code>. Requests to the agent are sent
by calling methods on this object. The constructing function
takes a plain object, which provides default parameters which
are used in the <code>request()</code> if no
overriding are given there.</p>
</div>
</div>
<div class="sect2">
<h3 id="js-request"><a class="anchor" href="#js-request"></a>Usage</h3>
<div class="paragraph">
<p>All functions of this library are available as methods of the
<code>Jolokia</code> object. The <code>options</code> argument needs to be
instantiated as usual and it takes a set of default options, which
can be overwritten by subsequent requests. On the most basic
layer is a single <code>request()</code> method,
which takes two arguments: A request object and an optional
options object. For example, a request for obtaining
the agent&#8217;s version for a agent running on the same server which
delivered the JavaScript looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let jolokia = new Jolokia({ url: "/jolokia" });
let response = await jolokia.request({ "type": "version" }, { "method": "post" });
console.log("Agent Version: " + response.value.agent);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the constructor is used with a single string argument, this
value is considered to be the agent&#8217;s access URL. I.e. in the
example above the construction of the
<code>Jolokia</code> could have been performed with a
single string argument (<code>new Jolokia("/jolokia")</code>).</p>
</div>
<div class="sect3">
<h4 id="js-request-format"><a class="anchor" href="#js-request-format"></a>Requests</h4>
<div class="paragraph">
<p>Jolokia requests and responses are represented as JSON
objects. They have exactly the same format, which is expected
and returned by the agent as defined in
<a href="jolokia_protocol.html" class="xref page">Jolokia Protocol</a> for POST requests. All request types are
supported.</p>
</div>
<div class="paragraph">
<p>The <code>request()</code> method expects as its first
argument either a single request object or, for bulk requests,
an array of request objects.</p>
</div>
<div class="paragraph">
<p>When Jolokia JavaScript library was using JQuery Ajax, there were two types of operations supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>synchronous - when <code>options</code> object didn&#8217;t contain <code>success</code> callback</p>
</li>
<li>
<p>asynchronous - when user specified <code>success</code> callback in <code>options</code> object</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Depending on this for synchronous
operations either a single response JSON object is returned or
an array of responses (in the order of the initial request
array). For asynchronous request one or more callbacks are
called for each response separately. See
<a href="#js-request-sync-async">Operational modes</a> for details.</p>
</div>
<div class="paragraph">
<p>With new Fetch API, there are more types of operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>callback mode</em> for compatibility purposes - you have to pass <code>success</code> and (optional) <code>error</code> callbacks through <code>options</code> object</p>
</li>
<li>
<p><em>recommended</em> JSON method in <em>promise mode</em> when there&#8217;s no <code>success</code> callback passed and <code>request()</code> returns a Promise object:</p>
<div class="ulist">
<ul>
<li>
<p>for HTTP status 200, it is resolved with the response value, which may be successfull or error Jolokia responses containing JSON data with response or error details obtained from <code>Response.json()</code></p>
</li>
<li>
<p>for HTTP status != 200, it throws an exception which is a Fetch <code>Response</code> object - user can attach <code>.catch()</code> to the promise and analyze the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">Response</a> object for headers, status code, etc.</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>special</em> Text method in <em>promise mode</em> when there&#8217;s no <code>success</code> callback, <code>dataType: "text"</code> is passed and <code>request()</code> returns a Promise object:</p>
<div class="ulist">
<ul>
<li>
<p>for HTTP status 200, it is resolved with the response value, which is plain text response obtained from <code>Response.text()</code>.</p>
</li>
<li>
<p>for HTTP status != 200 it&#8217;s the same as in <em>recommended</em> JSON method</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>low level</em> Response method in <em>promise mode</em>, when <code>resolve: "response"</code> is passed with <code>options</code> and <code>request()</code> returns a Promise object:</p>
<div class="ulist">
<ul>
<li>
<p>for any HTTP status code, the returned promise is resolved with entire <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">Response</a> object and user is free to call <code>Response.json()</code>, <code>Response.text()</code>, <code>Response.blob()</code> or any method from <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">Response API</a>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Remember - when no <code>success</code> callback is passed, the returned Promise has to be configured for resolution:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>by attaching <code>.then()</code> to get the value (both successful and error Jolokia responses - all within successful HTTP response (status == <code>200</code>))</p>
</li>
<li>
<p>by attaching <code>.catch()</code> to catch the exceptions:</p>
<div class="ulist">
<ul>
<li>
<p>a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">Response</a> object when there is some HTTP response</p>
</li>
<li>
<p>a <code>DOMException</code> or <code>TypeError</code> when there&#8217;s a networking or configuration error (see <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch#exceptions">fetch exceptions</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>by using <code>await jolokia.request()</code> to get the response</p>
</li>
<li>
<p>by surrounding with <code>try..catch</code> when there&#8217;s no <code>.catch()</code> used</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For convenience, in both <em>callback</em> and <em>promise</em> modes, we can pass <code>fetchError</code> callback method in the options (in <code>request()</code> call or initially when creating <code>Jolokia</code> instance). Before Jolokia 2.1.0 this option was passed directly to <code>$.ajax()</code> call in jQuery. This callback has the following signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">function(response, error)</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the parameters are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>response</code> is a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response">Response</a> object when available</p>
</li>
<li>
<p><code>error</code> is an exception object thrown by <code>fetch()</code> call (see <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch#exceptions">fetch exceptions</a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows a single and bulk request call to
the Jolokia agent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let jolokia = new Jolokia({ "url": "/jolokia" })
let req1 = { "type": "read", "mbean": "java.lang:type=Memory", "attribute": "HeapMemoryUsage" }
let req2 = { "type": "list" }
let response = await jolokia.request(req1)
let responses = await jolokia.request([ req1, req2 ])</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="js-request-options"><a class="anchor" href="#js-request-options"></a>Request options</h4>
<div class="paragraph">
<p>Each request can be configured with a set of optional parameters
provided either as default during construction of the
<code>Jolokia</code> object or as optional last
parameter for the request object. Also a request can carry a
<code>config</code> attribute, which can be used for all
processing parameters (<a href="jolokia_protocol.html#processing-parameters" class="xref page">Processing parameters</a>).
The known options are summarized in <a href="#js-request-options-table">Table 1, &#8220;Request options&#8221;</a></p>
</div>
<table id="js-request-options-table" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Request options</caption>
<colgroup>
<col style="width: 20%;">
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>url</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Agent URL (mandatory)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Either "post" or "get" depending on the desired HTTP method
(case does not matter).  Please note, that bulk requests are
not possible with "get". On the other hand, JSONP requests
are not possible with "post" (which obviously implies that
bulk request cannot be used with JSONP requests). Also, when
using a <code>read</code> type request for multiple
attributes, this also can only be sent as "post"
requests. If not given, a HTTP method is determined
dynamically. If a method is selected which doesn&#8217;t fit to the
request, an error is raised.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dataType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The type of data specified to Jolokia request. The default value is <code>json</code>,
and the response is parsed as JSON to an object. If the value is <code>text</code>,
the response is returned as plain text without parsing. The client is then
responsible for parsing the response. This can be useful when a custom JSON
parsing is necessary. The value is returned as Promise&#8217;s resolution value.<br>
Jolokia Simple API (jolokia-simple.js) doesn&#8217;t support <code>text</code> as dataType.<br>
<strong>Added since jolokia.js 2.0.2</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>success</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Callback function which is called for a successful
request. The callback receives the response as single
argument. If no <code>success</code> callback is given, then
the request returns a Promise.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>error</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Callback in case a Jolokia error occurs. A Jolokia error is
one, in which the HTTP request succeeded with a status code
of 200, but the response object contains a Jolokia (not HTTP) status other than
OK (200) which happens if the request JMX operation
fails. This callback receives the full Jolokia response
object (with a key <code>error</code> set). If no error
callback is given, but <code>success</code> is available, the error response is printed to the JavaScript
console by default.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fetchError</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A callback invoked when <code>fetch()</code> returns a <code>Response</code> object with HTTP status different than 200 or simply <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch#exceptions">throws an exception</a>.</p>
<p class="tableblock">This callback can be specified both in <em>callback</em> and <em>promise</em> mode - both at <code>request()</code> time and <code>Jolokia</code> instantiation time.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>credentials</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This option is passed directly to <code>fetch()</code> call. See <a href="https://developer.mozilla.org/en-US/docs/Web/API/RequestInit#headers">headers option</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>username</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A username used for HTTP authentication</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>password</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A password used for HTTP authentication</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timeout for the HTTP request used with <a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/timeout_static">Abort Signal</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>headers</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This option is passed directly to <code>fetch()</code> call.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxDepth</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maximum traversal depth for serialization of complex return values</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxCollectionSize</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maximum size of collections returned during serialization.
If larger, the collection is returned truncated.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxObjects</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maximum number of objects contained in the response.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>serializeLong</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">How to serialize long values in the JSON response: <code>number</code> or <code>string</code>.
The default <code>number</code> simply serializes longs as numbers in JSON.
If set to <code>string</code>, longs are serialized as strings.
It can be useful when a JavaScript client consumes the JSON response,
because numbers greater than the max safe integer don&#8217;t retain their precision
in JavaScript.<br>
<strong>Added since Jolokia 2.0.3</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ignoreErrors</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set to "true", errors during JMX operations and JSON
serialization are ignored. Otherwise if a single
deserialization fails, the whole request returns with an
error. This works only for certain operations like pattern
reads.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>canonicalNaming</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defaults to false for initiali property lists on object names; if set to "true" then canonical (sorted) order of properties will be used.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>includeRequest</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether the response object should contain related request object.<br>
This option may be configured globally and overridden at request time.
When <code>false</code>, bulk responses have to be correlated with requests by matching
the requests using index number - responses come in the same order as requests.<br>
<strong>Added since Jolokia 2.1.0</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>listKeys</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether the response object for <code>list()</code> operation should contain <code>keys</code> field
that lists all the keys obtained from each <code>javax.management.ObjectName</code> of the response.
This may save you time parsing the name yourself.<br>
<strong>Added since Jolokia 2.1.0</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>listCache</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A flag (defaults to <code>false</code>) to enable <em>optimized list response</em>.<br>
With this flag enabled, <code>list()</code> operation returns a bit different structure (that&#8217;s why we&#8217;ve upgraded protocol version to <code>8.0</code>) where some MBeans may <em>point to</em> cached, shared MBeanInfo JSON fragment. This heavily decreases the size of <code>list()</code> response.<br>
<strong>Added since Jolokia 2.1.0</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>serializeException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If true then in case of an error, the exception itself is returned in
it JSON representation under the key <code>error_value</code>
in the response object.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>includeStackTrace</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By default, a stacktrace is returned with every error (key: <code>stacktrace</code>)
This can be omitted by setting the value of this option to <code>false</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ifModifiedSince</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The <code>LIST</code> operations provides an
optimization in that it remembers, when the set of
registered MBeans has been changes last. If a timestamp
(in epoch seconds) is provided with this parameter, then
the LIST operation returns an empty response
(i.e. <code>value</code> is null) and a
<code>status</code> code of 304 (Not Modified) if
the MBeans haven&#8217;t changed. If you use the request
scheduler (<a href="#js-request-options-table">Table 1, &#8220;Request options&#8221;</a>)
then this feature can be used to get the callbacks called
only if a value is returned. For the normal request, the
error callback is called which must check the status itself.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="js-request-sync-async"><a class="anchor" href="#js-request-sync-async"></a>Operational modes</h4>
<div class="paragraph">
<p>Requests can be handled either with Promises or callbacks.
If a <code>success</code> callback is given in the
request options, the <code>fetch()</code> promise is handled by Jolokia.
The callback gets these arguments:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a Jolokia JSON
response object (see <a href="jolokia_protocol.html#request-response" class="xref page">Requests and Responses</a>)</p>
</li>
<li>
<p>an integer index indicating for which response this callback is being
called.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For bulk requests, this index corresponds to the array
index of the request which lead to this response. The value of
this option can be an array of callback functions which are
called in a round robin fashion when multiple responses are
received in case of bulk requests. These callbacks are called
only when the returned Jolokia response has a status code of
<code>200</code>, otherwise the callback(s) given with
the <code>error</code> option are consulted. If no error
callback is given, the error is printed on the console by
default. As for success callbacks, error callbacks receive the
Jolokia error response as a JSON object.</p>
</div>
<div class="paragraph">
<p>The following example shows callback-based requests for a single
Jolokia request as well as for bulk request with multiple
callbacks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let jolokia = new Jolokia("/jolokia");

// Single request with a single success callback
jolokia.request(
  {
    "type": "read",
    "mbean": "java.lang:type=Memory",
    "attribute": "HeapMemoryUsage"
  },
  {
    "success": function(response) {
      if (response.value.used / response.value.max &gt; 0.9) {
        console.info("90% of heap memory exceeded");
      }
    },
    "error": function(response) {
      console.info("Jolokia request failed: " + response.error);
    }
  }
);

// Bulk request with multiple callbacks
jolokia.request(
  [
    {
      "type": "read",
      "mbean": "java.lang:type=Threading",
      "attribute": "ThreadCount"
    },
    {
      "type": "read",
      "mbean": "java.lang:type=Runtime",
      "attribute": [ "VmName", "VmVendor" ]
    }
  ],
  {
    "success": [
      function(response) {
        console.log("Number of threads: " + response.value);
      },
      function(response) {
        console.log("JVM: " + response.value.VmName + " -- " + response.value.VmVendor);
      }
    ],
    "error": function(response) {
      alert("Jolokia request failed: " + response.error);
    }
  }
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both callbacks, <code>success</code> and
<code>error</code>, are only called when HTTP response code is <code>200</code>.
In case of an error on the HTTP level It is the responsibility of user
to <em>attach</em> <code>.catch()</code> to the returned Promise object. The passed function is called with the
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Response"><code>Response</code></a> object, so we can get more information. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">const response = await jolokia.request({ type: "version" })
  .catch(r =&gt; {
      if (r.status &lt;= 400) {
        // handle non-critical error
        console.warn(r.statusText)
      } else {
        // handle codes like 404 or 500
        console.warn("Critical error", r.statusText)
      }
  })</code></pre>
</div>
</div>
<div class="paragraph">
<p>As explained in <a href="jolokia_protocol.html#request-response" class="xref page">Requests and Responses</a> the Jolokia
agent supports two HTTP methods, <code>GET</code> and
<code>POST</code>. <code>POST</code> is more
powerful since it supports more features. e.g. bulk requests and
JMX proxy requests are only possible with POST. By default, the
Jolokia JavaScript library selects an HTTP method automatically,
which is <code>GET</code> for simple cases and <code>POST</code>
for more sophisticated requests. The HTTP method can be
overridden by setting the option <code>method</code> to
<code>"get"</code> or <code>"post"</code>.</p>
</div>
<div class="paragraph">
<p>There are some limitations in choosing the HTTP method depending
on the request and other options given:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bulk requests (i.e. an array of multiple requests) can only be
used with <code>POST</code>.</p>
</li>
<li>
<p><code>READ</code> requests for multiple attributes
(i.e. the <code>attribute</code> request parameter is
an array of string values) can only be used with
<code>POST</code>.</p>
</li>
<li>
<p>The JMX proxy mode (see <a href="proxy_mode.html" class="xref page">Proxy Mode</a>) can only be used
with <code>POST</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_promises"><a class="anchor" href="#_using_promises"></a>Using Promises</h3>
<div class="paragraph">
<p>Without callbacks we can leverage full potential of promises.</p>
</div>
<div class="paragraph">
<p>The example we&#8217;ve shown to describe <code>success</code> and <code>error</code> callbacks can be written using promises:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let jolokia = new Jolokia("/jolokia");

// Single request with a single success callback
let response = await jolokia.request({
    "type": "read",
    "mbean": "java.lang:type=Memory",
    "attribute": "HeapMemoryUsage"
  }).catch(r =&gt; {
      console.info("Jolokia request failed: " + r.statusText);
  })
if (response &amp;&amp; response.value.used / response.value.max &gt; 0.9) {
    console.info("90% of heap memory exceeded")
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="js-simple"><a class="anchor" href="#js-simple"></a>Simple API</h3>
<div class="paragraph">
<p>Building upon the basic
<code>Jolokia.request()</code> method, a simplified
access API is available. It is contained in
<code>jolokia-simple.js</code> (from <code>@jolokia.js/simple</code> npm package) which must be included after
<code>jolokia.js</code>. This API provides dedicated
method for the various request types and supports all options as
described in <a href="#js-request-options-table">Table 1, &#8220;Request options&#8221;</a>.</p>
</div>
<div class="paragraph">
<p>There is one notable difference for asynchronous callbacks and
synchronous return values though: In case of a successful call,
the callback is fed with the response&#8217;s
<code>value</code> object, not the full response
(i.e. <code>response.value</code> instead of <code>response</code>).
Similar when a <code>Promise</code> is returned, it is resolved with
the value itself from the response and not entire response.</p>
</div>
<div class="paragraph">
<p>There are also differences in error handling between <em>simple</em> and <em>normal</em> API:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>for callback mode, the Jolokia error message is passed in the same way</p>
</li>
<li>
<p>for promise mode, if HTTP return code is 200, but it is a Jolokia error, instead of returning
the error JSON message, its <code>error</code> field is thrown as an exception. HTTP error codes different that 200 are handled in the same way (by throwing or returning Fetch Response object)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Remember - to deal with values directly, <code>await</code> has to be used on the Promise returned from simple API.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getAttribute(mbean, attribute, path, opts)</code></dt>
<dd>
<p>This method returns the value of an JMX attribute
<code>attribute</code> of an MBean <code>mbean</code>. A path
can be optionally given, and the optional request options are
given as last argument(s). The return value for synchronous
operations are the attribute&#8217;s value, for callback
operations (i.e. <code>opts.success != null</code>) it is
<code>null</code>. See <a href="protocol/read.html" class="xref page">Reading attributes (read)</a> for
details.</p>
<div class="paragraph">
<p>For example, the following method call can be used
to synchronously fetch the current heap memory usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let memoryUsed = await jolokia.getAttribute("java.lang:type=Memory", "HeapMemoryUsage", "used");</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>setAttribute(mbean, attribute, value, path, opts)</code></dt>
<dd>
<p>For setting an JMX attribute, this method takes the MBean&#8217;s
name <code>mbean</code>, the attribute
<code>attribute</code> and the value to set as
<code>value</code>. The optional <code>path</code> is the
<em>inner path</em> of the attribute on which
to set the value (see <a href="protocol/write.html" class="xref page">Writing attributes (write)</a> for
details). The old value of the attribute is returned or
given to a <code>success</code> callback.</p>
<div class="paragraph">
<p>To enable verbose mode in the memory-handling beans, use</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let gsLoggingWasOn = await jolokia.setAttribute("java.lang:type=Memory", "Verbose", true);</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>execute(mbean, operation, arg1, arg2, &#8230;&#8203;, opts)</code></dt>
<dd>
<p>With this method, a JMX operation can be executed on the
MBean <code>mbean</code>. Beside the operation&#8217;s name
<code>operation</code>, one or more arguments can be given
depending on the signature of the JMX operation. The
return value is the return value of the operation. See
<a href="protocol/exec.html" class="xref page">Executing JMX operations (exec)</a> for details.</p>
<div class="paragraph">
<p>The following exampled asynchronously fetches a thread dump
as a JSON object and logs it into the console:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">jolokia.execute("java.lang:type=Threading", "dumpAllThreads(boolean,boolean)", true, true, {
  "success": function(value) {
    console.log(JSON.stringify(value));
  }
});</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>search(mBeanPattern, opts)</code></dt>
<dd>
<p>Searches for one or more MBeans whose object names fit the
pattern <code>mBeanPattern</code>. The return value is a list
of strings with the matching MBean names or <code>null</code>
if none is found. See <a href="protocol/search.html" class="xref page">Searching MBeans (search)</a> for details.</p>
<div class="paragraph">
<p>The following example looks up all application servers
available in all domains:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let servletNames = await jolokia.search("*:j2eeType=Servlet,*");</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>list(path, opts)</code></dt>
<dd>
<p>For getting meta information about registered MBeans,
the <code>list</code> command can be used. The
optional <code>path</code> points into this meta
information for retrieving partial information. The format
of the return value is described in detail in
<a href="protocol/list.html" class="xref page">Listing MBeans (list)</a>.</p>
<div class="paragraph">
<p>This example fetches only the meta information for the
attributes of the
<code>java.lang:type=OperatingSystem</code> MBean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let attributesMeta = await jolokia.list("java.lang/type=OperatingSystem/attr");</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>version(opts)</code></dt>
<dd>
<p>The <code>version</code> method returns the
agent&#8217;s version, the protocol version, and possibly some
additional server-specific information. See
<a href="protocol/version.html" class="xref page">Getting the agent version (version)</a> for more information about this
method.</p>
<div class="paragraph">
<p>A sample return value for an Apache Tomcat server looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "agent": "2.5.0",
  "protocol": "8.0",
  "details": {
    "agent_version": "2.1.0-SNAPSHOT",
    "agent_id": "192.168.0.221-72527-6baa8838-servlet",
    "server_product": "tomcat",
    "server_vendor": "Apache",
    "server_version": "10.1.28",
    "secured": true,
    "url": "http://192.168.0.221:8080/jolokia"
  },
  "id": "192.168.0.221-72527-6baa8838-servlet",
  "config": {
    ...
  },
  "info": {
    "proxy": {},
    "jmx": {}
  }
}</code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="js-poller"><a class="anchor" href="#js-poller"></a>Request scheduler</h3>
<div class="paragraph">
<p>A <code>Jolokia</code> object can be also used for
periodically sending requests to the agent. Therefore requests
can be registered to the client object, and a poller can be
started and stopped. All registered requests are send at once
with a single bulk request so this is a quite efficient method for
periodically polling multiple values.</p>
</div>
<div class="paragraph">
<p>Here is a simple example, which queries the heap memory usage
every 10 seconds and prints out the used memory on the console:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let jolokia = new Jolokia("/jolokia")
handle = jolokia.register(function(resp) {
  console.log("HeapMemory used: " + resp.value);
},
{
  "type": "read",
  "mbean": "java.lang:type=Memory",
  "attribute": "HeapMemoryUsage", "path": "used"
});

jolokia.start(10000);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>handle = jolokia.register(callback, request, request,&#8230;&#8203;.)</code></dt>
<dd>
<p>This method registers one or more request for being
periodically fetched. <code>callback</code> can be either a
function or an object.</p>
<div class="paragraph">
<p>If a function is given or an object with an attribute
<code>callback</code> holding a function, then this
function is called with all responses received as
argument, regardless whether the individual response
indicates a success or error state.</p>
</div>
<div class="paragraph">
<p>If the first argument is an object with two callback
attributes <code>success</code> and <code>error</code>,
these functions are called for <em>each</em> response
separately, depending whether the response indicates
success or an error state. If multiple requests have been
registered along with this callback object, the callback
is called multiple times, one for each request in the same
order as the request are given.  As second argument, the
handle which is returned by this method is given and as
third argument the index within the list of requests.</p>
</div>
<div class="paragraph">
<p>If the first argument is an object, an additional
<code>config</code> attribute with processing
parameters can be given which is used as default for the
registered requests. Requests with a
<code>config</code> section take precedence.</p>
</div>
<div class="paragraph">
<p>Furthermore, if a <code>onlyIfModified:
true</code> exists in the callback object, then the
<code>success</code> and <code>error</code>
callbacks are called only if the result changed on the
server side. Currently, this is supported for the
<code>list</code> operation only in which case the
callback is only called when MBean has been registered or
deregistered since the last call of the scheduler. If a
single <code>callback</code> function is used
which gets all responses for a job at once, then this
function is called only with the responses, which carry a
value. If none of the registered requests produced a
response with value (i.e. the server decided that there
was no update for any request), then a call to the callback function is
skipped completely.</p>
</div>
<div class="paragraph">
<p><code>register()</code> returns a handle which can be used
later for unregistering these requests.</p>
</div>
<div class="paragraph">
<p>In the following example two requests are registered along
with a single callback function, which takes two responses
as arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">handle = jolokia.register(function(resp1, resp2) {
  console.log("HeapMemory used: " + resp1.value);
  console.log("ThreadCount: " + resp2.value);
},
{
  "type": "read",
  "mbean": "java.lang:type=Memory",
  "attribute": "HeapMemoryUsage",
  "path": "used"
},
{
  "type": "read",
  "mbean": "java.lang:type=Threading",
  "attribute": "ThreadCount"
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the next example, a dedicated <code>success</code>
and <code>error</code> callback are provided, which are
called individually for each request (in the given
order):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">jolokia.register(
  {
    "success": function(resp) {
      console.log("MBean: " + resp.mbean + ", attr: " + resp.attribute + ", value: " + resp.value);
    },
    "error": function(resp) {
      console.log("Error: " + resp.error_text);
    },
    config: {
      "serializeException": true
    },
    "onlyIfModified": true
  },
  {
    "type": "list",
    "config": {
      "maxDepth": 2
    }
  },
  {
    "type": "read",
    "mbean": "java.lang:type=Threading",
    "attribute": "ThreadCount",
    "config": {
      "ignoreErrors": true
    }
  },
  {
    "type": "read",
    "mbean": "bla.blu:type=foo",
    "attribute": "blubber"
  }
);</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>jolokia.unregister(handle)</code></dt>
<dd>
<p>Unregister one or more requests registered with
<code>handle</code> so that they are no longer polled
with the scheduler.</p>
</dd>
<dt class="hdlist1"><code>jolokia.jobs()</code></dt>
<dd>
<p>Return an array of handles for all registered jobs. This array can be freely manipulated, its a copy of
the handle list.</p>
</dd>
<dt class="hdlist1"><code>jolokia.start(period)</code></dt>
<dd>
<p>Startup the scheduler for requeting the agent every
<code>period</code> milliseconds. If the scheduler is
already running, it adapts its scheduling period according
to the given argument. If no <code>period</code> is given,
the period provided during construction time (with the
option <code>fetchInterval</code>) is used. The default
value is 30 seconds.</p>
</dd>
<dt class="hdlist1"><code>jolokia.stop()</code></dt>
<dd>
<p>Stop the scheduler. If the scheduler is not running,
nothing happens. The scheduler can be restarted after it
has been stopped.</p>
</dd>
<dt class="hdlist1"><code>jolokia.isRunning()</code></dt>
<dd>
<p>Checks whether the scheduler is running. Returns
<code>true</code> if this is the case, <code>false</code>
otherwise.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="client-java"><a class="anchor" href="#client-java"></a>Java Client Library</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This documentation section is related to the current Jolokia version.
For previous Jolokia versions the chapter is available here:
<a href="client/java-old.html" class="xref page">Java Client Library (Jolokia versions before 2.4.0)</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Java client library provides an easy access to the Jolokia
Agent using Java API.<br>
Sure, <a href="https://jcp.org/en/jsr/detail?id=160">JSR-160, JMX Remote API</a> also provides a
Java based remote access to MBeans and one might wonder about
the benefits of another Jolokia Java binding. There are several,
though:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It provides a typeless access to remote MBeans. The big
advantage is that for any non-OpenMBean access to custom typed
objects is still possible without having the type information
locally in the classpath.</p>
</li>
<li>
<p>Jolokia can be used in scenarios where JSR-160 connectors can not
be used. I.e. in firewall secured environments it is much easier
to get through to a Jolokia Agent using HTTP than to a JSR-160 connector
using RMI as the transport protocol.</p>
</li>
<li>
<p><em>Remoteness</em> is explicit in this API instead
of JSR-160 connector&#8217;s seeked <em>transparent
remoteness</em>. RMI has some arguable conceptual
advantages, but hiding all the remote aspects proved to have quite
some disadvantages when it comes to the programming
model. Explicit awareness of a 'heavy-weight' remote call is
better than false transparency in order to know the price tag.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Java client library follows a strict request-response
paradigm, much like the underlying HTTP. It uses generics heavily
and can be centered around three classes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.jolokia.client.JolokiaClient</code> is the client side class, which
has various variants of an <code>execute()</code> methods for
sending requests.</p>
</li>
<li>
<p>These methods take one or more
<code>org.jolokia.client.request.JolokiaRequest</code> objects as arguments and</p>
</li>
<li>
<p>return one or more <code>org.jolokia.client.request.JolokiaResponse</code> objects as a result.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_jolokiaclient_spi"><a class="anchor" href="#_jolokiaclient_spi"></a>JolokiaClient SPI</h3>
<div class="paragraph">
<p>Since the initial Jolokia release <a href="https://github.com/jolokia/jolokia/commits/v0.80/" class="externalLink" target="_blank" rel="noopener">in 2010</a>, Jolokia
Client was implemented using <a href="https://hc.apache.org/httpcomponents-client-4.5.x/index.html" class="externalLink" target="_blank" rel="noopener">Apache HttpClient 4</a>.<br>
This gives us 4 external dependencies: HttpClient4, HttpCore4, Commons Codec and Commons Logging.</p>
</div>
<div class="paragraph">
<p><a href="https://openjdk.org/jeps/321" class="externalLink" target="_blank" rel="noopener">JEP 321</a> introduced real HTTP Client API available in the JDK itself.
<code>java.net.HttpURLConnection</code> was not suitable for more serious scenarios.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/jolokia/jolokia/issues/565">jolokia#565</a> was created in 2023, but it took a while to find a way to use JDK HTTP Client in Jolokia. While we <em>could</em> consider Apache HttpClient4 as deprecated and move entirely to JDK HTTP Client, it turned out that it&#8217;s possible to support both.<br>
And more.</p>
</div>
<div class="paragraph">
<p>Jolokia 2.4.0 introduced a breaking API change (violating a bit the <a href="https://semver.org/" class="externalLink" target="_blank" rel="noopener">Semantic Versioning guidelines</a>), because we wanted to achieve few goals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>rename <code>J4pClient</code> to <code>JolokiaClient</code></p>
</li>
<li>
<p>keep the Jolokia Client API as a set of <code>execute()</code> methods that accept <em>Jolokia request(s)</em> and return <em>Jolokia response(s)</em></p>
</li>
<li>
<p>remove strict dependency of <code>JolokiaClient</code> on particular HTTP Client implementation (for example <code>org.apache.http.client.HttpClient</code> was used as an argument of <code>J4pClient</code> constructor and <code>J4pClientBuilder</code> was accepting <code>org.apache.http.client.CookieStore</code>)</p>
</li>
<li>
<p>make <code>JolokiaClient</code> interface implementation-agnostic, but allow implementation-specific customization</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Effectively we broke the API by renaming the class and removing the HttpClient4-specific arguments (renaming wouldn&#8217;t happen without the removal).</p>
</div>
<div class="paragraph">
<p>The goals were achieved by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>introducing <code>org.jolokia.client.spi.HttpClientSpi</code> SPI interface</p>
</li>
<li>
<p>providing default implementation of this SPI interface based on JDK HTTP Client</p>
</li>
<li>
<p>moving the implementation from Jolokia 2.3.0 to an SPI implementation based on <a href="https://hc.apache.org/httpcomponents-client-4.5.x/index.html" class="externalLink" target="_blank" rel="noopener">Apache HttpClient 4</a></p>
</li>
<li>
<p>creating a new implementation based on <a href="https://hc.apache.org/httpcomponents-client-5.5.x/index.html" class="externalLink" target="_blank" rel="noopener">Apache HttpClient 5</a></p>
</li>
<li>
<p>leveraging <code>/META-INF/services/org.jolokia.client.spi.HttpClientBuilder</code> <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/ServiceLoader.html" class="externalLink" target="_blank" rel="noopener">Service Loader</a> interface.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Now, starting from Jolokia 2.4.0, users can create and call Jolokia Client, while the particular HTTP Client implementation
will be discovered automatically. And with default implementation (based on JDK HTTP Client) we no longer need <em>any</em> external dependencies.</p>
</div>
</div>
<div class="sect2">
<h3 id="client-java-tutorial"><a class="anchor" href="#client-java-tutorial"></a>Tutorial</h3>
<div class="paragraph">
<p>Here is a sample application using <code>JolokiaClient</code> to get the amount of used heap memory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.jolokia.client.JolokiaClient;
import org.jolokia.client.request.*;

public class MemoryDemo {
  public static void main(String[] args) {
    JolokiaClient client = new JolokiaClientBuilder().url("http://localhost:7778/jolokia")
        .user("jolokia")
        .password("jolokia")
        .build(); <i class="conum" data-value="1"></i><b>(1)</b>
    JolokiaReadRequest request
        = new JolokiaReadRequest("java.lang:type=Memory", "HeapMemoryUsage"); <i class="conum" data-value="2"></i><b>(2)</b>
    request.setPath("used"); <i class="conum" data-value="3"></i><b>(3)</b>
    JolokiaReadResponse response = client.execute(request); <i class="conum" data-value="4"></i><b>(4)</b>
    System.out.println("Memory used: " + response.getValue()); <i class="conum" data-value="5"></i><b>(5)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>JolokiaClient</code> object is used using a <code>JolokiaClientBuilder</code> builder</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A <code>JolokiaReadRequest</code> is created to specify an MBean name and its attribute to fetch</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A <em>path</em> into the complex structure (here: <code>java.lang.management.MemoryUsage</code>) is specified</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The request is sent using the Jolokia Client and a related <code>JolokiaReadResponse</code> is obtained</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>A value is printed from the response</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In order to compile and run this example, we need only one library: <code>jolokia-client-java-2.5.0.jar</code>. See <a href="/download.html">Download</a>.</p>
</div>
<div class="paragraph">
<p>For Maven users, the following dependency is sufficient. It will use two transitive Jolokia dependencies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>jolokia-json-2.5.0.jar</code> - for JSON serialization</p>
</li>
<li>
<p><code>jolokia-core-2.5.0.jar</code> - for data conversion</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.jolokia&lt;/groupId&gt;
    &lt;artifactId&gt;jolokia-client-java&lt;/artifactId&gt;
    &lt;version&gt;2.5.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_other_http_client_implementation"><a class="anchor" href="#_using_other_http_client_implementation"></a>Using other HTTP Client implementation</h3>
<div class="paragraph">
<p>If we want to use HTTP Client implementation from external library (instead of the one provided by the JDK itself), it&#8217;s enough to add one of
these dependencies to the <code>CLASSPATH</code>:</p>
</div>
<div class="listingblock">
<div class="title">Use Apache Http Client 4</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.jolokia&lt;/groupId&gt;
    &lt;artifactId&gt;jolokia-client-java-httpclient4&lt;/artifactId&gt;
    &lt;version&gt;2.5.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Use Apache Http Client 5</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.jolokia&lt;/groupId&gt;
    &lt;artifactId&gt;jolokia-client-java-httpclient5&lt;/artifactId&gt;
    &lt;version&gt;2.5.0&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="client-client"><a class="anchor" href="#client-client"></a>JolokiaClient and JavaClientBuilder API</h3>
<div class="paragraph">
<p><code>JolokiaClient</code> is the entry point for sending
requests to a remote Jolokia agent. It can be created in multiple
ways. For simple cases, public constructors are provided taking
the mandatory Jolokia agent URI and optionally an explicitly selected implementation
of <code>org.jolokia.client.spi.HttpClientSpi</code> SPI interface (to skip the autodiscovery mechanism).</p>
</div>
<div class="paragraph">
<p>The recommended style
is to use the <code>JolokiaClientBuilder</code>, though. This way, all
the parameters for HTTP communication can easily be set:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">JolokiaClient client = new JolokiaClientBuilder().url("http://localhost:7778/jolokia")
    .user("jolokia")
    .password("jolokia")
    .socketBufferSize(16384)
    .socketTimeout(5000)
    // ...
    .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The builder supports the following parameters with the given
defaults:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. JolokiaClient parameters</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Parameter</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>url</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The URL to the Jolokia agent. This is the only mandatory parameter. Can be specified as a String or a <code>java.net.URI</code> object.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>user</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Username when authentication is used. If not set, no
authentication is used. If set, <code>password</code>
must be set, too</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>password</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Password used for authentication. Only used when
<code>user</code> is set.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>target</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A JMX JSR-160 ServiceURL which should be used by the agent
as the <em>real</em> target. This parameter should
be set if the client is used for accessing the agent in
<a href="proxy_mode.html" class="xref page">Proxy Mode</a>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>targetUser</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The JSR-160 user to use when using the proxy mode. If not
given (and <code>target</code> is set), then no
authentication is used for JSR-160 communication.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>targetPassword</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSR-160 Password to use for the proxy mode.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>connectionTimeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The timeout in milliseconds until a connection is
established. A timeout value of zero is interpreted as an
infinite timeout.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>20000</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>socketTimeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defines the socket timeout (<code>SO_TIMEOUT</code>) in milliseconds,
which is the timeout for waiting for data  or, put differently,
a maximum period inactivity between two consecutive data packets.
A timeout value of zero is interpreted as an infinite timeout.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pooledConnection</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies, that the underlying HttpClient should use pooled
connection manager, which is thread safe and can service
connection requests from multiples threads
simultaneously. This is important if the
<code>JolokiaClient</code> is to be used in a multi
threaded context. The size of the pool is restricted by the
parameter <code>maxTotalConnection</code>.
<code>ThreadSafeClientConnManager</code> is the
underlying connection manager. Pooled connections are the
default.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>singleConnection</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies that single connection should be used which
maintains only one active connection at a time.  Even though
<code>JolokiaClient</code> is still thread-safe it
ought to be used by one execution thread only. The
underlying connection manager is
<code>SingleClientConnManager</code> Pooled
connections are the default.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxTotalConnections</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defines the number of total connections to be pooled. It
is only used when <code>pooledConnection</code> is
used.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>20</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>defaultMaxConnectionsPerRoute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defines the number of total connections per route. It
is only used when <code>pooledConnection</code> is
used.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>20</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxConnectionPoolTimeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defines the timeout for waiting to obtain a connection
from the pool. This parameter is only used when
<code>pooledConnections</code> are used.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>500</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contentCharset</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defines the charset to be used per default for encoding
content body.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ISO-8859-1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>expectContinue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Activates <code>Expect: 100-Continue</code> handshake
for the entity enclosing methods.  The purpose of the
<code>Expect: 100-Continue</code> handshake to allow a
client that is sending a request message with a request body
to determine if the origin server is willing to accept the
request (based on the request headers) before the client
sends the request body.  The use of the <code>Expect:
100-continue</code> handshake can result in noticeable
performance improvement for entity enclosing requests that
require the target server&#8217;s authentication.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tcpNoDelay</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Determines whether Nagle&#8217;s algorithm is to be used. The
Nagle&#8217;s algorithm tries to conserve bandwidth by minimizing
the number of segments that are sent. When applications wish
to decrease network latency and increase performance, they
can disable Nagle&#8217;s algorithm (that is enable
<code>TCP_NODELAY</code>). Data will be sent
earlier, at the cost of an increase in bandwidth
consumption.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>socketBufferSize</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Determines the size of the internal socket buffer in bytes
used to buffer data while receiving and transmitting HTTP
messages.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>8192</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>proxy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Determines http proxy server. It can be defined as
<code>http://user:password@host:port</code>. <em>user</em> and
<em>password</em> are optional.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>useProxyFromEnvironment</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set the proxy for this client based on <code>http_proxy</code> system environment variable.
Expect formats are <code>http://user:pass@host:port</code> or <code>http://host:port</code>
Example: <code>http://tom:sEcReT@my.proxy.com:8080</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>responseExtractor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A response objectAccessor can be used for hooking into the JSON
deserialization process when a JSON response is converted
into a <code>JolokiaResponse</code> object. By
default, the received JSON object is examined for a status
code of 200 and only then creates a response
object. Otherwise an exception is thrown. An objectAccessor is
specified by the interface
<code>JolokiaResponseExtractor</code>. Beside the
default objectAccessor, an alternate objectAccessor
<code>ValidatingResponseExtractor</code> can be
used, which instead of throwing an exception returns a
<code>null</code> object when the response has a status of
404. An objectAccessor can be specified as extra argument to the
execute method, too.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.jolokia.client.response.ValidatingResponseExtractor</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>defaultHttpHeaders</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A map of default HTTP headers that should be sent with Jolokia requests.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>keystore</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A keystore with client credentials to be used with HTTPS connections. The keystore
can be specified either as <code>java.nio.file.Path</code> or <code>java.security.KeyStore</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>keystorePassword</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Password to the keystore</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>keyPassword</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Password to the Client key inside the keystore</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>truststore</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A truststore with server certificates to be used with HTTPS connections. The truststore
can be specified either as <code>java.nio.file.Path</code> or <code>java.security.KeyStore</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>truststorePassword</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Password to the truststore</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>protocolVersion</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TLS protocol version to be used with HTTPS connections. When this option is not set,
SSL configuration won&#8217;t be used. We can use for example <code>TLSv1.3</code>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <code>JolokiaClient</code> provides various variants
of a <code>execute()</code> method, which take
either one single request or a list of requests. For a single
request, the preferred HTTP method (GET or POST) can be
specified optionally. The <code>List&lt;R&gt;</code>
argument type can be used only for a homogeneous bulk request,
i.e. for multiple requests of the same time. Otherwise an
untyped list must be used.</p>
</div>
<div class="paragraph">
<p>Each request can be tuned by giving a map of processing options
along with their values to the <code>execute()</code>
method. The possible options are specified using <code>org.jolokia.client.JolokiaQueryParameter</code> enum and are shown in the below table:
<a href="#client-java-queryopts">Table 3, &#8220;JolokiaClient query parameters&#8221;</a>.</p>
</div>
<table id="client-java-queryopts" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. JolokiaClient query parameters</caption>
<colgroup>
<col style="width: 20%;">
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">J4pQueryParameter enum</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MAX_DEPTH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maximum traversal depth for serialization of complex
objects. Use this with a "list" request to restrict the
depth of the returned meta data tree.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MAX_COLLECTION_SIZE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maximum size of collections returned during serialization.
If larger, a collection is truncated to this size.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MAX_OBJECTS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maximum number of objects returned in the response&#8217;s value.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SERIALIZE_LONG</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An option about how to serialize <code>long</code> values. We have an option to use <code>number</code> or <code>string</code>.
This is more relevant for JavaScript, where the maximum value of a <code>long</code> type is different than in Java.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IGNORE_ERRORS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option for ignoring errors during JMX operations and JSON
serialization.  This works only for certain operations like
pattern reads and should be either <code>true</code>
or <code>false</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INCLUDE_STACKTRACE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to include a stack trace in the response when an
error occurs.  The allowed values are
<code>true</code> for inclusion,
<code>false</code> if no stacktrace should be
included or <code>runtime</code> if only
<code>RuntimeException</code>s should be
included. Default is <code>true</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SERIALIZE_EXCEPTION</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to include a JSON serialized version of the
exception. If set to <code>true</code>, the exception
is added under the key <code>error_value</code> in
the response. Default is <code>false</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CANONICAL_NAMING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether property keys of <code>ObjectNames</code>
should be ordered in the canonical way or in the way that
they are created. The allowed values are either
<code>true</code> in which case the canonical key
order (== alphabetical sorted) is used or
<code>false</code> for getting the keys as
registered. Default is <code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MIME_TYPE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Which MIME type to use with the response. only <code>text/plain</code> and <code>application/json</code> are supported.
This is not very important for the Java Client.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INCLUDE_REQUEST</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether the response object should contain related request object.<br>
This option may be configured globally and overridden at request time.
When <code>false</code>, bulk responses have to be correlated with requests by matching
the requests using index number - responses come in the same order as requests.<br>
<strong>Available since Jolokia 2.1.0</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LIST_KEYS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to enable <code>org.jolokia.service.jmx.handler.list.ListKeysDataUpdater</code>, so the object names are split
into <code>key=value</code> pairs in the response</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IF_MODIFIED_SINCE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can be specified as milliseconds of the UNIX epoch for <code>list</code>
requests. If there were no changes after this timestamp in the
registered MBeans, a response with HTTP 304 return code is returned.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LIST_CACHE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to use optimized version of the <code>list</code> response. It is <em>critical</em> for the scenarios where the
Jolokia Agent has access to a lot of different MBeans of the same MBean interface.<br>
<strong>Available since Jolokia 2.1.0</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LIST_INTERFACES</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether the <code>list</code> response should add information about all the interfaces implemented by MBeans. This options was added to support <code>javax.management.MBeanServerConnection.isInstanceOf()</code> method in <code>jolokia-client-jmx-adapter</code><br>
<strong>Available since Jolokia 2.5.0</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OPEN_TYPES</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether the <code>list</code> response should return information about <code>javax.management.openmbean.OpenType</code>s used by
the MBeans. This allows much better insight into the complex data structures used by the MBeans.<br>
<strong>Available since Jolokia 2.5.0</strong></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_implementation_specific_configuration"><a class="anchor" href="#_implementation_specific_configuration"></a>Implementation specific configuration</h3>
<div class="paragraph">
<p>Because Jolokia Client supports now (since version 2.5.0) 3 different implementations, we&#8217;ve added a way to configure
implementation-specific details. For example the connection pool can be configured for Apache HttpClient using Java API, but
for JDK HTTP Client, system properties are used.</p>
</div>
<div class="paragraph">
<p>We can pass a <em>customizer</em> to <code>org.jolokia.client.JolokiaClientBuilder</code> and here&#8217;s an example of calling Apache HttpClient5
specific methods when configuring Jolokia Client. We can also grab an instance of actual implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import org.apache.hc.client5.http.classic.HttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClientBuilder;
import org.jolokia.client.JolokiaClient;
import org.jolokia.client.JolokiaClientBuilder;

public class App {

  public static void main(String[] args) throws Exception {
    JolokiaClient client = new JolokiaClientBuilder().url("http://localhost:8080/jolokia")
        .withCustomizer(HttpClientBuilder.class, (HttpClientBuilder builder) -&gt; {
            builder.setUserAgent("My Client based on HttpClient 5");
            called[0] = true;
        }).build();
    HttpClient realClient = client.getHttpClient(HttpClient.class);
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="client-java-requests"><a class="anchor" href="#client-java-requests"></a>Request types</h3>
<div class="paragraph">
<p>For each request type a dedicated request object is provided
which all are subclasses from
<code>JolokiaRequest</code>. For all requests it can be
specified which HTTP method is to be used by setting the
property <code>preferredHttpMethod</code> to either
<code>GET</code> or <code>POST</code>.</p>
</div>
<div class="paragraph">
<p>Each request type has a corresponding response type which used
for the return values of the
<code>JolokiaClient.execute()</code>.</p>
</div>
<div class="paragraph">
<p>The constructor of each kind of request can take a
<code>JolokiaTargetConfig</code> as argument for using a
request in <a href="proxy_mode.html" class="xref page">Proxy Mode</a>. This
configurational object holds the JMX service url and
(optionally) credentials for JSR-160 authentication. When
given, this proxy target specification overrides any default
proxy configuration set during the initialization of the
<code>JolokiaClient</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>JolokiaReadRequest</code> and <code>JolokiaReadResponse</code></dt>
<dd>
<p><code>JolokiaReadRequest</code> is a read request to
get one or more attributes from one or more MBeans within
a single request. Various constructor variants can be used
to specify one or more attributes along with the
ObjectName (which can be a pattern). A
<code>path</code> can be set as property for
specifying an <em>inner path</em>, too.</p>
<div class="paragraph">
<p><code>JolokiaReadResponse</code> is the
corresponding response type and allows typed access to the
fetched value for a single attribute fetch or to multiple
values for a multi attribute read. In the latter case, the
found object and attributes names can be retrieved as
well.</p>
</div>
<div class="paragraph">
<p>For more information on fetching the value of multiple
attributes and multiple MBeans at once, please refer to
<a href="protocol/read.html" class="xref page">Reading attributes (read)</a> or the Javadoc of
<code>JolokiaReadResponse</code>.</p>
</div>
</dd>
<dt class="hdlist1"><code>JolokiaWriteRequest</code> and <code>JolokiaWriteResponse</code></dt>
<dd>
<p>A <code>JolokiaWriteRequest</code> is used to set
the value of an MBean attribute. Beside the mandatory
object and attribute name the value must be give in the
constructor as well. Optionally a <code>path</code>
can be provided, too. Only certain types for the given
value can be serialized properly for calling the Jolokia
agent as described in <a href="jolokia_protocol.html#serialization-request" class="xref page">Request parameter serialization</a>.</p>
<div class="paragraph">
<p>The old value is returned as <code>JolokiaWriteResponse</code>'s value.</p>
</div>
</dd>
<dt class="hdlist1"><code>JolokiaExecRequest</code> and <code>JolokiaExecResponse</code></dt>
<dd>
<p><code>JolokiaExecRequest</code>'s are used for
executing operation on MBeans. The constructor takes as
mandatory arguments the MBean&#8217;s object name, the operation
name and any arguments required by the operation. Only
certain types for the given arguments can be serialized
properly for calling the Jolokia agent as described in
<a href="jolokia_protocol.html#serialization-request" class="xref page">Request parameter serialization</a>.</p>
<div class="paragraph">
<p>The returned <code>JolokiaExecResponse</code>
contains the return value of the operation called.</p>
</div>
</dd>
<dt class="hdlist1"><code>JolokiaSearchRequest</code> and <code>JolokiaSearchResponse</code></dt>
<dd>
<p>A <code>JolokiaSearchRequest</code> contains a
valid single MBean object name pattern which is used for
searching MBeans.</p>
<div class="paragraph">
<p>The <code>JolokiaSearchResponse</code> holds a
list of found object names.</p>
</div>
</dd>
<dt class="hdlist1"><code>JolokiaListRequest</code> and <code>JolokiaListResponse</code></dt>
<dd>
<p>For obtaining meta data on MBeans a
<code>JolokiaListRequest</code> should be used. It
can be used with a <em>inner path</em> to
obtain only a subtree of the response, otherwise the whole
tree as described in <a href="jolokia_protocol.html#response-list" class="xref page">List response</a> is
returned. With the query parameter
<code>maxDepth</code> can be used to restrict the
depth of returned tree.</p>
<div class="paragraph">
<p>The single value of a
<code>JolokiaListResponse</code> is a tree (or
subtree) as a JSON object, which has the format described
in <a href="jolokia_protocol.html#response-list" class="xref page">List response</a>.</p>
</div>
</dd>
<dt class="hdlist1"><code>JolokiaVersionRequest</code> and <code>JolokiaVersionResponse</code></dt>
<dd>
<p>A <code>JolokiaVersionRequest</code> request the
Jolokia agent&#8217;s version information and takes no
argument.</p>
<div class="paragraph">
<p>The <code>JolokiaVersionResponse</code> returns the
agent&#8217;s version (<code>agentVersion</code>), the
protocol version (<code>protocolVersion</code>), the
application server product name
(<code>product</code>), the vendor name
(<code>vendor</code>) and any extra info
(<code>extraInfo</code>) specific to the platform
the Jolokia is running on.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="client-java-exceptions"><a class="anchor" href="#client-java-exceptions"></a>Exceptions</h3>
<div class="paragraph">
<p>In case of an error when executing a request a
<code>JolokiaException</code> or one its subclass is
thrown.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>JolokiaConnectException</code></dt>
<dd>
<p>Exception thrown when the connection to the server
fails. It contains the original
<code>java.net.ConnectException</code> as nested value.</p>
</dd>
<dt class="hdlist1"><code>JolokiaTimeoutException</code></dt>
<dd>
<p>Exception thrown in case of an timeout. The nested
exception depends on the HTTP Client implementation used, but should be an instance of
<code>java.io.IOException</code></p>
</dd>
<dt class="hdlist1"><code>JolokiaHttpException</code></dt>
<dd>
<p>Exception thrown in when the HTTP response is not delivered using
HTTP status code 200. In such case, the response does not contain JSON body.</p>
</dd>
<dt class="hdlist1"><code>JolokiaRemoteException</code></dt>
<dd>
<p>Generic exception thrown when an exception occurred on the
remote side. This is the case when the JSON response
obtained is an error response as described in
<a href="jolokia_protocol.html#responses" class="xref page">Responses</a>. The error type, error value, the
status, the request leading to this error and the remote
stacktrace as string) can be obtained from this exception.</p>
</dd>
<dt class="hdlist1"><code>JolokiaBulkRemoteException</code></dt>
<dd>
<p>Exception thrown when a bulk request fails on the remote
side. This contains a mixed list which contains the
<code>JolokiaRemoteException</code> occurred as well
as the <code>JolokiaResponse</code> objects for the
requests, which succeeded. The list obtained by
<code>getResults()</code> contains these
objects in the same order as the list of requests given to
<code>execute</code>. All responses and remote
exceptions can also be obtained separately in homogeneous
lists.</p>
</dd>
<dt class="hdlist1"><code>JolokiaException</code></dt>
<dd>
<p>Base exception thrown, when no other exception fits,
i.e. when the exception happened on the client side. The
original exception is contained as nested exception.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="client-jmx-adapter"><a class="anchor" href="#client-jmx-adapter"></a>Jolokia JMX Connector Client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="jmx_remote_guide.html" class="xref page">JMX Remote Guide</a> provides in-depth information about <a href="https://jcp.org/en/jsr/detail?id=160" class="externalLink" target="_blank" rel="noopener">JSR-160</a> - the remote part of the <a href="https://jcp.org/en/jsr/detail?id=3" class="externalLink" target="_blank" rel="noopener">JMX specification</a>.<br>
A JMX Connector is specified as a way to access a remote MBeanServer using <code>javax.management.MBeanServerConnection</code> interface, as if it was available locally. The default implementation shipped with standard JDK is based on RMI protocol and uses <code>javax.management.remote.rmi.RMIServer</code> (RMI) remote interface.</p>
</div>
<div class="paragraph">
<p>Jolokia Agent is an implementation of JMX Protocol Adaptor, but additionally provides a <em>client part</em> of the JMX Connector. This means we can access a remote JVM where a Jolokia agent is running using <code>javax.management.MBeanServerConnection</code> interface.<br>
Internally invocations of <code>MBeanServerConnection</code> interface are translated into Jolokia Client library calls.</p>
</div>
<div class="paragraph">
<p>This allows you to use tools that leverage a JSR-160 <code>MBeanServerConnection</code> such as <a href="https://docs.oracle.com/en/java/javase/17/management/using-jconsole.html" class="externalLink" target="_blank" rel="noopener">JConsole</a>, <a href="https://visualvm.github.io/" class="externalLink" target="_blank" rel="noopener">Visual VM</a> or
<a href="https://www.oracle.com/java/technologies/jdk-mission-control.html" class="externalLink" target="_blank" rel="noopener">Java Mission Control</a> for connecting to a Jolokia endpoint.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Recommended plugins</div>
<div class="paragraph">
<p>For Java Mission Control, a set of plugins are provided at
<a href="https://github.com/skarsaune/jmc-cloud-extensions/" class="bare externalLink" target="_blank" rel="noopener">https://github.com/skarsaune/jmc-cloud-extensions/</a> and for
Java Visual VM a Jolokia plugin can be downloaded from <a href="https://skarsaune.github.io/jolokia-jmc-update-site/visualvm/org-jolokia-jmx-plugin.nbm" class="bare externalLink" target="_blank" rel="noopener">https://skarsaune.github.io/jolokia-jmc-update-site/visualvm/org-jolokia-jmx-plugin.nbm</a></p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Starting with version 9.1.0, Java Mission Control <a href="https://www.oracle.com/java/technologies/javase/jmc9-release-notes.html#R9_1_0" class="externalLink" target="_blank" rel="noopener">provides built-in Jolokia support</a>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="remote-jmx-example"><a class="anchor" href="#remote-jmx-example"></a>Connecting to a Jolokia Agent using JSR-160 JMX Connector Client</h3>
<div class="paragraph">
<p>Chapter <a href="jmx_remote_guide.html#_obtaining_rmi_jmx_connector" class="xref page">Obtaining an RMI JMX connector (client)</a> shows how the JMX code uses the <code>protocol</code>
part of <code>JMXServiceURL</code> to locate a <code>javax.management.remote.JMXConnectorProvider</code> which is used to create a <code>JMXConnector</code> implementation. Refer to the entire <a href="jmx_remote_guide.html" class="xref page">JMX Remote Guide</a> chapter for more details.</p>
</div>
<div class="paragraph">
<p>The example below shows how to connect programmatically to a Jolokia enabled Java process listening on <code>localhost:8778</code> using the <em>canonical</em> JSR-160 API code.</p>
</div>
<div class="paragraph">
<p>For this example to work you need the following prerequisites:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Jolokia&#8217;s <code>jolokia-client-jmx-adapter-2.5.0-standalone.jar</code>
must be on the classpath. See the <a href="/download.html">Download page</a> for the latest versions of this adapter jar.</p>
</li>
<li>
<p>Jolokia has to be accessible, running at
<a href="http://localhost:8778/jolokia/" class="bare">http://localhost:8778/jolokia/</a>. If user/password authentication is enabled for the agent, pass the credentials using <code>javax.management.remote.JMXConnector.CREDENTIALS</code> option (which is standard for remote JMX).</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import java.util.HashMap;
import java.util.Map;

import javax.management.MBeanServerConnection;
import javax.management.ObjectName;
import javax.management.openmbean.CompositeData;
import javax.management.remote.JMXConnector;
import javax.management.remote.JMXConnectorFactory;
import javax.management.remote.JMXServiceURL;

public class ConnectWithJolokiaDemo {
    public static void main(String[] args) throws Exception {
        Map&lt;String, Object&gt; options = new HashMap&lt;&gt;();
        // Add user &amp; password if the Agent is secured:
        options.put(JMXConnector.CREDENTIALS, new String[] { "jolokia", "jolokia" });

        JMXConnector connector = JMXConnectorFactory.connect(
                new JMXServiceURL("service:jmx:jolokia+http://localhost:7778/jolokia"),
                options);

        MBeanServerConnection connection = connector.getMBeanServerConnection();
        CompositeData heapMemoryUsage = (CompositeData) connection
                .getAttribute(ObjectName.getInstance("java.lang:type=Memory"), "HeapMemoryUsage");
        System.out.println("Memory used: " + heapMemoryUsage.get("used"));

        connector.close();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>javax.management.MBeanServerConnection</code> interface is a base interface for <code>javax.management.MBeanServer</code> with almost
the same methods. However, as mentioned in <a href="jmx_remote_guide.html#_jmx_remote_rmi_connector_details" class="xref page">JMX Remote RMI Connector - the details</a>,
the important differences are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>all the methods throw <code>java.io.IOException</code> to indicate that the call should be treated as remote (expect I/O exceptions)</p>
</li>
<li>
<p>there are no <code>registerMBean()</code> and <code>unregisterMBean()</code> methods</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_connecting_to_a_remote_jolokia_agent_using_jconsole"><a class="anchor" href="#_connecting_to_a_remote_jolokia_agent_using_jconsole"></a>Connecting to a remote Jolokia Agent using JConsole</h3>
<div class="paragraph">
<p>By providing an implementation of <code>javax.management.remote.JMXConnector</code> and <code>javax.management.MBeanServerConnection</code>, Jolokia can easily
be used with tools that rely on these interfaces!</p>
</div>
<div class="paragraph">
<p>One of these tools is <a href="https://docs.oracle.com/en/java/javase/17/management/using-jconsole.html" class="externalLink" target="_blank" rel="noopener">JConsole</a> which is shipped
with JDK distribution and is available in <code>$JAVA_HOME/bin</code> directory.</p>
</div>
<div class="paragraph">
<p>JConsole access remote JVM processes using a JMX Connector which is discovered by providing proper <code>JMXServiceURL</code> in this connection dialog:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="_images/jconsole2.png" alt="jconsole connection dialog">
</div>
</div>
<div class="paragraph">
<p>Jolokia Agent may run on plain HTTP connection or may use HTTPS with or without certificate authentication. Before Jolokia 2.5.0 we could
only use one form of JMXServiceURL: <code>service:jmx:jolokia://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code> and HTTPS was used only if the port ended with <code>443</code>.</p>
</div>
<div class="paragraph">
<p>Because <a href="https://www.ietf.org/rfc/rfc2609.html#section-2.1">RFC 2609</a> allows <code>+</code> sign in the <code>resname</code> component of the service URI, we&#8217;ve decided to support additional forms of Jolokia URIs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>service:jmx:jolokia://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code> - compatible with previous behavior - switching to HTTPS if the port ends with <code>443</code></p>
</li>
<li>
<p><code>service:jmx:jolokia+http://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code> - using HTTP explicitly</p>
</li>
<li>
<p><code>service:jmx:jolokia+https://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code> - using HTTPS explicitly</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Of course for HTTPS connection we should be able to configure more than just the URL. Remember that Jolokia Client is a Java API, so developers
using this API directly in their Java code can configure various aspects programmatically. With JConsole all we have is the command line, system properties and environment variables - and this is how Jolokia 2.5.0 and later allows to configure more options.</p>
</div>
<div class="paragraph">
<p>First - we need to tell JConsole how to find Jolokia JMX Connector classes and here&#8217;s how to do it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ jconsole -J-Djava.class.path=$HOME/.m2/repository/org/jolokia/jolokia-client-jmx-adapter/{jolokia-version}/jolokia-client-jmx-adapter-{jolokia-version}-standalone.jar</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you have problems with running JConsole (which is a Java Swing application) on Linux with Gtk L&amp;F or on 4K monitor, please use these additional options: <code>-J-Dswing.defaultlaf=javax.swing.plaf.metal.MetalLookAndFeel -J-Dsun.java2d.uiScale=3</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>No additional options are needed when using HTTP.<br>
This is enough to connect to remote JVM process and get all the information needed by JConsole! Jolokia JMX Connector
properly translates all the complex types available in JMX MBeanServer, for example Flight Recorder:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="_images/jconsole-jfr.png" alt="jconsole connection dialog">
</div>
</div>
<div class="sect3">
<h4 id="_tls_configuration_for_jconsole_and_jolokia_jmx_connector"><a class="anchor" href="#_tls_configuration_for_jconsole_and_jolokia_jmx_connector"></a>TLS Configuration for JConsole and Jolokia JMX Connector</h4>
<div class="paragraph">
<p>Traditionally the TLS configuration for Java uses <em>stores</em> of two types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a <em>keystore</em> contains client certificate(s) and private key(s)</p>
</li>
<li>
<p>a <em>truststore</em> contains server issuer certificate(s) and/or Certificate Authority (CA) certificates</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Java supports two kinds of keystore/truststore formats - proprietary JKS and standard PKCS#12.<br>
However Jolokia (see <a href="https://github.com/jolokia/jolokia/issues/911" class="bare externalLink" target="_blank" rel="noopener">https://github.com/jolokia/jolokia/issues/911</a>) gives users more options - we can now specify certificates and keys in other formats:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>X.509 certificates not embedded in Java keystores/truststores</p>
</li>
<li>
<p>PKCS#1 RSA keys</p>
</li>
<li>
<p>DSA keys</p>
</li>
<li>
<p>PKCS#8 RSA, DSA and EC keys</p>
</li>
<li>
<p>PKCS#5 (PBE) encrypted RSA, DSA and EC keys</p>
</li>
<li>
<p>all in either DER or PEM formats</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>We&#8217;ve introduced these system properties for Jolokia JMX Connector</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">System property</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia.keystore</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Location (path) to a Java keystore with client certificate and private key</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia.keystorePassword</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Password for the entire keystore</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia.keystoreAlias</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Alias for the keystore for a private-key entry that should be used for client TLS authentication</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia.truststore</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Location (path) to a Java keystore with server/ca data to validate the server</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia.truststorePassword</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Password for the truststore</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia.clientCertificate</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Location of a X.509 client certificate (PEM or DER) when not using a Java keystore</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia.clientKey</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Location of PKCS#1 (RSA) or PKCS#8 private key (PEM or DER, encrypted or not) matching the client certificate</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia.clientKeyAlgorithm</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Algorithm to be used for <code>java.security.KeyFactory#getInstance()</code> which usually can be deduced from PKCS#1/PKCS#8/PKCS#5 structure</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia.clientKeyPassword</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Password for the private key specified separately or for a key inside the client keystore</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia.caCertificate</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Location of a CA certificate (PEM or DER) when not using the truststore</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia.username</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Username for Basic authentication</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia.password</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Password for Basic authentication - mind that Basic Authentication should <strong>not</strong> be used without TLS</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia.connectionTimeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Connection (establishment) timeout in milliseconds</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jolokia.readTimeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read (socket) timeout in milliseconds</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>What&#8217;s more - all the above options can be specified as environmental variables too! We just have to switch to proper convention - for example <code>jolokia.readTimeout</code> system property name becomes <code>JOLOKIA_READ_TIMEOUT</code> environmental property name.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example to run JConsole with TLS client authentication:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ JOLOKIA_CLIENT_KEY_PASSWORD=jolokia \
    jconsole \
    -J-Dswing.defaultlaf=javax.swing.plaf.metal.MetalLookAndFeel \
    -J-Dsun.java2d.uiScale=3 \
    -J-Djava.class.path=$HOME/.m2/repository/org/jolokia/jolokia-client-jmx-adapter/{jolokia-version}/jolokia-client-jmx-adapter-{jolokia-version}-standalone.jar \
    -J-Djolokia.caCertificate=ca.cer.pem \
    -J-Djolokia.clientCertificate=client.cer.pem \
    -J-Djolokia.clientKey=client-private.key-pk8.pem</pre>
</div>
</div>
<div class="paragraph">
<p>Here, <code>client-private.key-pk8.pem</code> is a PEM file with a <code>-----BEGIN ENCRYPTED PRIVATE KEY-----</code> header and Jolokia can properly decrypt it using a password specified using <code>JOLOKIA_CLIENT_KEY_PASSWORD</code> environmental variable.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="kubernetes-jmx-example"><a class="anchor" href="#kubernetes-jmx-example"></a>JSR-160 Connection to a JVM running in Kubernetes</h3>
<div class="paragraph">
<p>If you are running a Jolokia-enabled JVM within a Kubernetes Pod, you can directly connect to this JVM from your local machine with the Jolokia JSR-160 connector. See the runnable example below for more details.</p>
</div>
<div class="paragraph">
<p>Before compiling and running the example below, please check that the following prerequisites are met:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Jolokia&#8217;s <code>remote-jmx-adapter-2.5.0-javaagent.jar</code>
must be on the classpath. See the <a href="/download.html">Download page</a> for the latest versions of this adapter jar.</p>
</li>
<li>
<p>In addition, the Jolokia Kubernetes extension
<code>jolokia-kubernetes-2.5.0-javaagent.jar</code>
must be on the classpath. This can be also downloaded from the
<a href="/download.html">Download page</a>.</p>
</li>
<li>
<p>Configuration and authentication for the Kubernetes context setup are as usual. I.e., you must be able to run <code>kubectl</code> with the cluster to connect to. You can check this by <code>kubectl get namespace</code>.</p>
</li>
<li>
<p>For the example below, we assume a Java process running in a Pod <code>petclinic-6959c9b4cb-gk8np</code> in namespace <code>default</code> that has a Jolokia agent enabled. This agent is supposed to listen on port <code>8778</code>.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import javax.management.remote.*;
import javax.management.ObjectName;
import org.jolokia.kubernetes.client.KubernetesJmxConnector;

public class ConnectInKubernetesDemo {
  public static void main(String[] args) {
    Map options = new HashMap();
    // Add the Kubernetes context from the Kubernetes configuration that
    // points to your cluster. By default, the currently active context
    // is used.
    // options.put(KubernetesJmxConnector.KUBERNETES_CLIENT_CONTEXT,
    //             "docker-desktop");
    JMXConnector connector = JMXConnectorFactory.connect(
        new JMXServiceURL("service:jmx:kubernetes:///default/petclinic-6959c9b4cb-gk8np:8778/jolokia/"),
        options);
    connector.connect();
    System.out.println("Memory used: " +
        connector.getMBeanServerConnection().getAttribute(
            ObjectName.getInstance("java.lang:type=Memory"),"HeapMemoryUsage"));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As an alternative to connecting programmatically to the Jolokia agent, you can also leverage <code>jconsole</code> to explore JMX on the remote JVM.
You need to add the Jolokia connector client libraries when launching <code>jconsole</code> like in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>java -cp jolokia-agent-jvm-2.5.0-javaagent.jar:\
jolokia-client-jmx-adapter-2.5.0-standalone.jar:\
jolokia-client-kubernetes-2.5.0-standalone.jar \
-Djconsole.showOutputViewer sun.tools.jconsole.JConsole</pre>
</div>
</div>
<div class="paragraph">
<p>After adding these Jolokia jars to <code>sun.tools.jconsole.JConsole</code> class we can then access remote server using Jolokia JMX URL:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/jconsole.png" alt="jconsole">
</div>
</div>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="extensions.html">Extending Jolokia</a></span>
  <span class="next"><a href="jolokia_jmx.html">JMX Support</a></span>
</nav>
</article>
  </div>
<footer class="footer">
  This page was built using the Antora default UI. The source code for this UI is licensed under the terms of the MPL-2.0 license. | Copyright  2010 -
  2025 Roland Hu
</footer>
<script id="site-script" src="../_/js/site.js" data-ui-root-path="../_"></script>
<script async src="../_/js/vendor/highlight.js"></script>
</main>
</div>
  </body>
</html>
