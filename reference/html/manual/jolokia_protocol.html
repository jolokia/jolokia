<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Jolokia Protocol :: Jolokia</title>
    <link rel="canonical" href="https://jolokia.org/manual/jolokia_protocol.html">
    <link rel="prev" href="proxy_mode.html">
    <link rel="next" href="jolokia_mbeans.html">
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../_/css/site.css">
    <link rel="stylesheet" href="../_/css/jolokia.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://jolokia.org">Jolokia</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="manual" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="index.html">Jolokia Manual</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="architecture.html">Architecture</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="extensions.html">Extending Jolokia</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="agents.html">Agents</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="security.html">Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="proxy_mode.html">Proxy Mode</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="jolokia_protocol.html">Jolokia Protocol</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="jolokia_mbeans.html">Jolokia MBeans</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="clients.html">Clients</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="jolokia_jmx.html">JMX Support</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="spring.html">Spring Support</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Jolokia Manual</span>
    <span class="version"></span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="index.html">Jolokia Manual</a></div>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Jolokia Manual</a></li>
    <li><a href="jolokia_protocol.html">Jolokia Protocol</a></li>
  </ul>
</nav>
<div class="edit-this-page"><a href="https://github.com/jolokia/jolokia/tree/main/src/documentation/manual/modules/ROOT/pages/jolokia_protocol.adoc">Help improving this page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Jolokia Protocol</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Jolokia uses a JSON-over-HTTP protocol which is described in
this chapter. The communication is based on a request-response
paradigm, where each request results in a single response.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">GET URLs are chatty</div>
<div class="paragraph">
<p>Keep in mind
that many web servers log the requested path of every request, including
parameters passed to a GET request, so sending messages over GET
often bloats server logs.</p>
</div>
<div class="paragraph">
<p>Another important aspect is that some ObjectNames may be complex (for example in Camel or ActiveMQ/Artemis) and POST
request is much more suitable when working with such MBeans.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Jolokia requests can be sent in two ways: Either as a HTTP GET
request, in which case the request parameters are encoded
completely in the URL. Or as a POST request where the request is
put into a JSON payload in the HTTP request&#8217;s body. GET based
requests are mostly suitable for simple use cases and for
testing the agent via a browser. The focus here is on
simplicity. POST based requests uses a JSON representation of
the request within the HTTP body. They are more appropriate for
complex requests and provide some additional features (e.g. bulk
requests are only possible with POST).</p>
</div>
<div class="paragraph">
<p>The response returned by the agent always uses JSON for its data
representation. It has the same format regardless whether GET or
POST requests are used.</p>
</div>
<div class="paragraph">
<p>The rest of this chapter is divided into two parts: First, the
general structure of requests and responses is explained after
which the representation of Jolokia supported operations is defined.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unfortunately the term <em>operation</em> is
used in different contexts which should be
distinguished from one another. <em>Jolokia operations</em> denote
the various kind of Jolokia requests (<code>read</code>, <code>exec</code>, &#8230;&#8203;), whereas <em>JMX
operations</em> are methods which can be invoked on an JMX
MBean. Whenever the context requires it, this documents uses
<em>Jolokia</em> or <em>JMX</em> as prefix.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="request-response"><a class="anchor" href="#request-response"></a>Requests and Responses</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jolokia knows about two different styles of handling
requests, which are distinguished by the HTTP method used: GET
or POST. Regardless of which method is used, the agent doesn&#8217;t
keep any state on the server side (except of course that
MBeans are obviously stateful most of the time). So in this aspect, the
communication can be considered
<a href="https://en.wikipedia.org/wiki/Representational_State_Transfer" class="externalLink" target="_blank" rel="noopener">REST</a>
like<sup class="footnote" id="_footnote_rest-comment">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>.</p>
</div>
<div class="sect2">
<h3 id="servlet-api-concepts"><a class="anchor" href="#servlet-api-concepts"></a>Some Servlet API concepts</h3>
<div class="paragraph">
<p>Before proceeding, let&#8217;s review some important concepts from <a href="https://jakarta.ee/specifications/servlet/5.0/jakarta-servlet-spec-5.0" class="externalLink" target="_blank" rel="noopener">Jakarta Servlet Specification 5</a>.</p>
</div>
<div class="paragraph">
<p><a href="https://jakarta.ee/specifications/servlet/5.0/jakarta-servlet-spec-5.0#request-path-elements" class="externalLink" target="_blank" rel="noopener">Chapter 3.5. Request Path Elements</a> splits full URI used to access Java Servlet container into three parts (query string is not included here):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>requestURI = contextPath + servletPath + pathInfo</pre>
</div>
</div>
<div class="paragraph">
<p>These 4 elements are accessed using these API calls:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>jakarta.servlet.http.HttpServletRequest.getRequestURI()</code></p>
</li>
<li>
<p><code>jakarta.servlet.http.HttpServletRequest.getContextPath()</code></p>
</li>
<li>
<p><code>jakarta.servlet.http.HttpServletRequest.getServletPath()</code></p>
</li>
<li>
<p><code>jakarta.servlet.http.HttpServletRequest.getPathInfo()</code></p>
<div class="dlist">
<dl>
<dt class="hdlist1">Request URI</dt>
<dd>
<p>this is simply full URI without query string</p>
</dd>
<dt class="hdlist1">Context path</dt>
<dd>
<p>this fragment selects the web application (one of potentially many running in single Servlet container). On Tomcat it is derived from the file name of WAR archive in <code>webapps/</code> directory. It may be <code>/</code> (for special <code>ROOT.war</code> on Tomcat).</p>
</dd>
<dt class="hdlist1">Servlet path</dt>
<dd>
<p>this is more complicated, as it indicates part of the URI that is used to select single servlet within single web application. When servlet mapping (<code>&lt;servlet-mapping&gt;/&lt;url-pattern&gt;</code> element in <code>WEB-INF/web.xml</code>) is <code>/path</code> or <code>/path/*</code>, servlet path is <code>/path</code>. Jolokia Agent WAR uses <code>/*</code>  mapping, so servlet path is empty.</p>
</dd>
<dt class="hdlist1">Path info</dt>
<dd>
<p>this is the URI part after servlet path, so for Jolokia, it is simply everything after <code>/jolokia</code> (when WAR agent is deployed to Tomcat as <code>webapps/jolokia.war</code>).</p>
</dd>
</dl>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="get-requests"><a class="anchor" href="#get-requests"></a>GET requests</h3>
<div class="paragraph">
<p>The simplest way to access the Jolokia agent is by sending
HTTP GET requests. These requests encode all their
parameters within the access URL. Jolokia uses
the <em>path info</em> part of an URL to extract the
parameters. Within the <em>path info</em>, each part is separated by
a slash (<code>/</code>). In general, the request URL
looks like</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;base-url&gt;/&lt;type&gt;/&lt;arg1&gt;/&lt;arg2&gt;/..../</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>&lt;base-url&gt;</code> specifies the URL
under which the agent is accessible and consists of protocol (<code>http</code> or <code>https</code>), host, port and
a <em>context path</em>.</p>
</div>
<div class="paragraph">
<p>It normally looks like
<code>http://localhost:8080/jolokia</code>, but depends on
your deployment setup.
The last part of such URL is the
<em>context root</em> of the deployed agent,
which by default is based on the agent&#8217;s filename
(e.g. <code>jolokia.war</code>).</p>
</div>
<div class="paragraph">
<p><code>&lt;type&gt;</code> specifies one of the
supported Jolokia operations (described in the next
section), followed by one or more operation-specific
parameters separated by slashes.</p>
</div>
<div class="paragraph">
<p>For example, the following URL executes a
<code>read</code> Jolokia operation on the MBean
<code>java.lang:type=Memory</code> for reading the
attribute <code>HeapMemoryUsage</code> (see
<a href="#read">Reading attributes (read)</a>). It is assumed, that the agent is
reachable under the base URL
<code><a href="http://localhost:8080/jolokia" class="bare">http://localhost:8080/jolokia</a></code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_escaping_rules_in_get_requests"><a class="anchor" href="#_escaping_rules_in_get_requests"></a>Escaping rules in GET requests</h3>
<div class="paragraph">
<p>GET requests are easy and straightforward - you can easily type them in browser address bar, bookmark or use with <code>curl</code>. However, there are limitations.</p>
</div>
<div class="paragraph">
<p><a href="https://datatracker.ietf.org/doc/html/rfc2396#section-3.3" class="externalLink" target="_blank" rel="noopener">RFC 2396</a> and newer <a href="https://datatracker.ietf.org/doc/html/rfc3986#section-3.3" class="externalLink" target="_blank" rel="noopener">RFC 3986</a> specify what is and what is not allowed in the URL (which is a subset of URI). <a href="https://datatracker.ietf.org/doc/html/rfc7230#section-2.7.3" class="externalLink" target="_blank" rel="noopener">RFC 7230</a> specifies usage of URIs within HTTP protocol.</p>
</div>
<div class="paragraph">
<p>As mentioned in <a href="#servlet-api-concepts">Some Servlet API concepts</a>, Jolokia uses <em>path info</em> to identify the type of operation to perform and its specific arguments (mbean names, attribute names for <code>read</code>/<code>write</code> operations or method name and arguments for <code>exec</code> operations).</p>
</div>
<div class="paragraph">
<p>RFC 3986 mentions that a URI:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>path component with data organized in hierarchical form, where <em>segments</em> are separated by <code>/</code> character (implicitly stating that <code>/</code> is forbidden as part of the segment)</p>
</li>
<li>
<p>query component with data organized in non-hierarchical form</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Also (and RFC 2396 says this explictly, while newer RFC 3986 only highlights the convention), some characters in the segments may have special meaning (usually to implement the <em>path parameters</em>). These are <code>;</code>, <code>,</code> and <code>=</code>. Finally, by the definition, <code>?</code> separates the path part from the query part, so <code>?</code> can&#8217;t be part of the path (and any segment of the path).</p>
</div>
<div class="paragraph">
<p>The problem is that mbean names or attribute values may use various characters which are illegal from the point of view of URI or HTTP specifications.</p>
</div>
<div class="paragraph">
<p>That&#8217;s where Jolokia URI encoding steps in. In theory <a href="https://en.wikipedia.org/wiki/Percent-encoding" class="externalLink" target="_blank" rel="noopener">URI encoding</a> should be sufficient, but it simply is not.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>You might wonder why simple URI encoding isn&#8217;t enough for
escaping slashes. The reason is simple - security.
For example, Tomcat returns HTTP error 400 with <code>Invalid URI: [The encoded slash character is not allowed]</code> message if you encode <code>/</code> as <code>%2F</code>. Jetty returns <code>Bad Message 400, reason: Ambiguous URI empty segment</code> when two slashes are used (<code>//</code>).
Other appservers might exhibit a similar
behaviour, so Jolokia uses an own escaping mechanism.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>If one of the Jolokia request parts contain a slash
(<code>/</code>) (e.g. as part of you bean&#8217;s name, which is often the case with Camel or ActiveMQ) it
needs to be escaped. An exclamation mark
(<code>!</code>) is used as escape character <sup class="footnote" id="_footnote_no-backslash">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>.
An exclamation mark itself needs to be doubled
for escaping. Any other character preceded by an exclamation
mark is taken literally. Table
<a href="#escape-rules">Table 1, &#8220;Escaping rules&#8221;</a> illustrates the escape rules as
used in GET requests. Also, if quotes are part of an GET
request the need to be escaped  with
<code>!"</code>.</p>
</div>
<table id="escape-rules" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Escaping rules</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Escaped</th>
<th class="tableblock halign-left valign-top">Unescaped</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!/</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!!</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!"</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!</code><em>(anything else)</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>(anything else)</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For example, to read the attribute <code>State</code>
on the MBean named
<code>jboss.jmx:alias=jmx/rmi/RMIAdaptor</code>, an
access URL like this has to be constructed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>.../read/jboss.jmx:alias=jmx!/rmi!/RMIAdaptor/State</pre>
</div>
</div>
<div class="paragraph">
<p>Client libraries like
<a href="https://search.cpan.org/~roland/jmx4perl" class="externalLink" target="_blank" rel="noopener">JMX::Jmx4Perl</a>
do this sort of escaping transparently.</p>
</div>
<div class="paragraph">
<p>Escaping can be avoided altogether if a slightly different
variant for a request is used (which doesn&#8217;t look that
REST-stylish, though). Instead of providing the information
as path-info, a query parameter <code>p</code> can be
used instead. This should be URL encoded, though. For the
example above, the alternative is</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost:8080/jolokia?p=/read/jboss.jmx:alias=jmx%2Frmi%2FRMIAdaptor/State</pre>
</div>
</div>
<div class="paragraph">
<p>This format <em>must</em> be used for GET
requests containing backslashes (<code>\</code>) since
backslashes can not be sent as part of an URL at all.</p>
</div>
<div class="paragraph">
<p>Summarizing, the recommended approach is to use POST requests if possible. If GET has to be used and escaping may be confusing with the server you used, use <code>p</code> query parameter. For GET requests with path segments, be careful about the escaping rules.</p>
</div>
</div>
<div class="sect2">
<h3 id="post-requests"><a class="anchor" href="#post-requests"></a>POST requests</h3>
<div class="paragraph">
<p>POST requests are the most powerful way to communicate
with the Jolokia agent. There are fewer escaping issues and it
allows for features which are not available with GET
requests. POST requests use a single Jolokia URL and put their payload
within the HTTP request&#8217;s body. This payload is represented
in <a href="https://www.json.org" class="externalLink" target="_blank" rel="noopener">JSON</a>, a
data serialization format originating from the JavaScript
world.</p>
</div>
<div class="paragraph">
<p>The JSON format for a single request is a JSON object, which
is essentially a map with keys (or
<em>attributes</em>) and values. All requests
have a common mandatory attribute,
<code>type</code>, which specifies the kind of JMX
operation to perform. The other attributes are either
operation specific as described in
<a href="#jolokia-operations">Jolokia operations</a> or are <em>processing
parameters</em> which influence the overall behaviour
and can be mixed in to any request. See
<a href="#processing-parameters">Processing parameters</a> for details. Operation specific attributes
can be either mandatory or optional and depend on the operation type.
In the following, if not mentioned otherwise, attributes are mandatory.
Processing parameters are always optional, though.</p>
</div>
<div class="paragraph">
<p>A sample read request in JSON format looks like the
following example. It has a <code>type</code>
<code>read</code>
(case doesn&#8217;t matter) and the three attributes
<code>mbean</code>, <code>attribute</code>
and <code>path</code> which are specific to a read
request.</p>
</div>
<div id="request-example" class="listingblock">
<div class="title">JSON Request</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type" : "read",
  "mbean" : "java.lang:type=Memory",
  "attribute" : "HeapMemoryUsage",
  "path" : "used"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each request JSON object results in a single JSON response
object contained in the HTTP answer&#8217;s body. A <em>bulk
request</em> contains multiple Jolokia requests within
a single HTTP request. This is done by putting individual
Jolokia requests into a JSON array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">[
  {
    "type" : "read",
    "attribute" : "HeapMemoryUsage",
    "mbean" : "java.lang:type=Memory",
    "path" : "used"
  },
  {
    "type" : "search",
    "mbean" : "*:type=Memory,*"
  }
]</code></pre>
</div>
</div>
<div class="paragraph">
<p>This request will result in a JSON array containing multiple
JSON responses within the HTTP response. They are returned
in same order as the requests in the initial bulk request.</p>
</div>
</div>
<div class="sect2">
<h3 id="responses"><a class="anchor" href="#responses"></a>Responses</h3>
<div class="paragraph">
<p>All responses are delivered as HTTP responses, but there&#8217;s clear distinction about HTTP and Jolokia error responses.
Generally we have 3 kinds of responses:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>suucessful response, which always is delivered with <code>HTTP 200</code> (or in special case with <code>HTTP 30x</code>) code and contains JSON object (whether the request was single request or bulk request).</p>
</li>
<li>
<p>error response delivered with <code>HTTP 200</code> code - this kind of error is related to problems at JMX level, when everything that&#8217;s needed to perform JMX operation is successfully extracted from HTTP request. For these responses, JMX error may be delivered in JSON response or part of the JSON response where bulk request was sent</p>
</li>
<li>
<p>error response delivered with <code>HTTP 4xx/5xx</code> codes - this happens when client sends invalid JSON (and Jolokia can&#8217;t even determine what should be done) or mismatched request parameters (for example <code>maxDepth=fourty-two</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Jolokia responses are always encoded in UTF-8 JSON, regardless whether the
request was a GET or POST request.  In general, two kinds of
responses can be classified: In the normal case, an HTTP
Response with response code <code>200</code> is returned, containing the
result of the operation as a JSON payload. In case of an
error, a <code>4xx</code> or <code>5xx</code> code will be returned and the JSON
payload contains details about the error
occurred (e.g. <code>404</code> means "not found"). (See
<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" class="externalLink" target="_blank" rel="noopener">this page</a>
for more information about HTTP error codes..). If the processing option
<code>ifModifiedSince</code> is given and the requested
value as been not changed since then, a response code of 304 is returned.
This option is currently only supported by the <code>list</code> request, for
other request types the value is always fetched.</p>
</div>
<div class="paragraph">
<p>In the non-error case a JSON response looks mostly the same
for each request type except for the
<code>value</code> attribute which is request type
specific.</p>
</div>
<div class="paragraph">
<p>The format of a single Jolokia response is:</p>
</div>
<div id="response-example" class="listingblock">
<div class="title">JSON Response</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "value": .... ,
  "status" : 200,
  "timestamp" : 1702391068,
  "request": {
    "type": ...,
    ....
  },
  "history": [
    {
      "value": ... ,
      "timestamp" : 1702391069
    },
    ....
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For successful requests, the <code>status</code> is
always <code>200</code> (the HTTP success code). The
<code>timestamp</code> contains the epoch
time<sup class="footnote" id="_footnote_epoch-time">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>
when the
request has been handled. The request leading to this
response can be found under the attribute
<code>request</code>. Finally and optionally, if
history tracking is switched on (see
<a href="#history">Tracking historical values</a>), an entry with key
<code>history</code> contains a list of historical
values along with their timestamps. History tracking is only
available for certain type of requests
(<code>read</code>, <code>write</code> and
<code>exec</code>). The <code>value</code>
is specific for the type of request, it can be a single
scalar value or a monster JSON structure.</p>
</div>
<div class="paragraph">
<p>If an error occurs, the <code>status</code> will be
a number different from <code>200</code>. An error
response looks like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "error_type": "java.lang.UnsupportedOperationException",
  "error": "java.lang.UnsupportedOperationException : No type with name 'java.lang:type=Memory' exists",
  "status": 400
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For status codes it is important to distinguish status
codes as they appear in Jolokia JSON response objects
and the HTTP status code of the (outer) HTTP
response. There can be many Jolokia status codes, one for
each Jolokia request contained in the single HTTP request. The
HTTP status code merely reflect the status of agent itself
(i.e. whether it could perform the operation at all), whereas the
Jolokia response status reflects the result of the
operation (e.g. whether the performed operation throws an
exception). So it is not uncommon to have an HTTP status
code of 200, but the contained JSON response(s) indicate
some errors.</p>
</div>
<div class="paragraph">
<p>I.e. the <code>status</code> has a code in the range
<code>400 .. 499</code> or <code>500 .. 599</code>
<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" class="externalLink" target="_blank" rel="noopener">as it is specified for HTTP return codes</a>.
The <code>error</code> JSON field contains an error
description. This is typically the message of an exception
occurred on the agent side<sup class="footnote" id="_footnote_mbeanexception-wrapping">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup>. Finally, <code>error_type</code> contains the Java class name
of the exception occurred.
The <code>stacktrace</code> contains a Java stacktrace
occurred on the server side (if any stacktrace is available and <code>includeStackTrace</code> option is set to <code>true</code>).</p>
</div>
<div class="paragraph">
<p>For each type of operation, the format of the
<code>value</code> entry is explained in
<a href="#jolokia-operations">Jolokia operations</a></p>
</div>
</div>
<div class="sect2">
<h3 id="paths"><a class="anchor" href="#paths"></a>Paths</h3>
<div class="paragraph">
<p>An <em>inner path</em> points to a certain
substructure (plain value, array, hash) within a a complex
JSON value. Think of it as something like "XPath lite". This
is best explained by an example:</p>
</div>
<div class="paragraph">
<p>The attribute <code>HeapMemoryUsage</code> of the MBean
<code>java.lang:type=Memory</code> can be
requested with the URL
<code>http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage</code>
which returns a complex JSON structure like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "mbean": "java.lang:type=Memory",
    "attribute": "HeapMemoryUsage",
    "type": "read"
  },
  "value": {
    "init": 524288000,
    "committed": 532676608,
    "max": 8334082048,
    "used": 27145000
  },
  "status": 200,
  "timestamp": 1702392020
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to get to the value for used heap memory you should
specify an inner path <code>used</code>, so that the
request
<code>http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage/used</code>
results in a response of <code>27145000</code> for the value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "path": "used",
    "mbean": "java.lang:type=Memory",
    "attribute": "HeapMemoryUsage",
    "type": "read"
  },
  "value": 27145000,
  "status": 200,
  "timestamp": 1702392075
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the attribute contains arrays at some level, use a numeric
index (0 based) as part of the inner path if you want to
traverse into this array.</p>
</div>
<div class="paragraph">
<p>For both, GET and POST requests, paths must be escaped as
described in <a href="#escape-rules">Table 1, &#8220;Escaping rules&#8221;</a> when they
contain slashes (<code>/</code>) or exclamation marks
(<code>!</code>).</p>
</div>
<div class="paragraph">
<p>Paths support wildcards <code>*</code> in a simple form. If given as a path part exclusively, it
matches any entry and path matching continues on the next level. This feature is especially
useful when using pattern read request together with paths. See <a href="#read">Reading attributes (read)</a> for details. A
<code>*</code> mixed with other characters in a path part has no special meaning and is used literally.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jolokia-operations"><a class="anchor" href="#jolokia-operations"></a>Jolokia operations</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="read"><a class="anchor" href="#read"></a>Reading attributes (read)</h3>
<div class="paragraph">
<p>Reading MBean attributes is probably the most used JMX method,
especially when it comes to monitoring. Concerning Jolokia, it is
also the most powerful one with the richest semantics. Obviously
the value of a single attribute can be fetched, but Jolokia
supports also fetching of a list of given attributes on a single
MBean or even on multiple MBeans matching a certain pattern.</p>
</div>
<div class="paragraph">
<p>Reading attributes are supported by both kinds of requests,
<code>GET</code> and <code>POST</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Don&#8217;t confuse fetching multiple attributes on possibly multiple
MBeans with bulk requests. A single read request will always
result in a single read response, even when multiple attribute
values are fetched. Only the single response&#8217;s structure of the
<code>value</code> will differ depending on what kind of
read request was performed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A read request for multiple attributes on the same MBean is
initiated by giving a list of attributes to the request. For a
POST request this is an JSON array, for a GET request it is a
comma separated list of attribute names (where slashes and
exclamation marks must be escaped as described in
<a href="#escape-rules">Escaping rules</a>). If no attribute is provided, then all
attributes are fetched. The MBean name can be given as a pattern
in which case the attributes are read on all matching MBeans. If a
MBean pattern and multiple attributes are requested, then only the
value of attributes which matches both are returned, the others
are ignored.</p>
</div>
<div class="paragraph">
<p>Paths can be used with pattern and multiple attribute read as well. In order to
skip the extra value levels introduced by a pattern read, the wildcard
<code>*</code> can be used. For example, a read request for the MBean Pattern
<code>java.lang:type=GarbageCollector,*</code> for the Attribute <code>LastGcInfo</code>
returns a complex structure holding information about the last garbage collection. If one is
looking only for the used memory during garbage collection, a path <code>used</code> could be used if
this request wouldn&#8217;t be a pattern request (i.e. refers a specific, single MBean).
But in this case since a
nested map with MBean and Attribute names is returned, the path <code>*/*/*/*/used</code> has to be used
in order to skip the extra levels (for different heaps/spaces) for applying the path.
Note that in the following example the final value is <em>not</em> the full GC-Info but only the
value of its <code>used</code> entry for different spaces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">"value": {
  "java.lang:name=G1 Young Generation,type=GarbageCollector": {
    "LastGcInfo": {
      "duration": 3,
      "memoryUsageBeforeGc": {
        "CodeHeap 'profiled nmethods'": 4780288,
        "G1 Old Gen": 4934656,
        "CodeHeap 'non-profiled nmethods'": 928256,
        "G1 Survivor Space": 4194304,
        "Compressed Class Space": 1331528,
        "Metaspace": 12812816,
        "G1 Eden Space": 20971520,
        "CodeHeap 'non-nmethods'": 1271296
      },
      "GcThreadCount": 5,
      "startTime": 786,
      "endTime": 789,
      "id": 2,
      "memoryUsageAfterGc": {
        "CodeHeap 'profiled nmethods'": 4780288,
        "G1 Old Gen": 9082880,
        "CodeHeap 'non-profiled nmethods'": 928256,
        "G1 Survivor Space": 2597960,
        "Compressed Class Space": 1331528,
        "Metaspace": 12812816,
        "G1 Eden Space": 0,
        "CodeHeap 'non-nmethods'": 1271296
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following rule of thumb applies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a wildcard is used, everything at that point in the path is
matched. The next path parts are used to match from there
on. All the values on this level are included.</p>
</li>
<li>
<p>Every other path part is literally compared against the values
on that level. If there is a match, this value is
<em>removed</em> in the answer so that at the end
you get back a structure with the values on the wildcard levels
and the leaves of the matched parts.</p>
</li>
<li>
<p>If used with wildcards, paths behave also like
filters. E.g. you can use a path <code>*/*/*/*/used</code> on
the MBean pattern <code>java.lang:*</code> and get back
only that portions which contains "used" as key, all others are
ignored.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="get-read"><a class="anchor" href="#get-read"></a>GET read request</h4>
<div class="paragraph">
<p>The GET URL for a read request has the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;base-url&gt;/read/&lt;mbean name&gt;/&lt;attribute name&gt;/&lt;inner path&gt;</pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. GET Read Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Part</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;mbean name&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/ObjectName.html" class="externalLink" target="_blank" rel="noopener">ObjectName</a>
of the MBean for which the attribute should be fetched. It
contains two parts: A domain part and a list of properties
which are separated by <code>:</code>. Properties
themselves are combined in a comma separated list of
key-value pairs. This name can be a pattern in which case
multiple MBeans are queried for the attribute value.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang:type=Memory</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;attribute name&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of attribute to read. This can be a list of Attribute
names separated by comma. According to URI compliance, some special characters need to be
escaped as described in
<a href="#escape-rules">Escaping rules</a>. If no attribute is given, all
attributes are read.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HeapMemoryUsage</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;inner path&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This optional part describes an <em>inner
path</em> as described in <a href="#paths">Paths</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>used</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>With this URL the used heap memory can be obtained:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage/used</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="post-read"><a class="anchor" href="#post-read"></a>POST read request</h4>
<div class="paragraph">
<p>A the keys available for read POST requests are shown in the
following table.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. POST Read Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>read</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mbean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MBean&#8217;s ObjectName which can be a pattern</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang:type=Memory</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>attribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Attribute name to read or a JSON array containing a list
of attributes to read. No attribute is given, then all attributes
are read.</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>HeapMemoryUsage</code></p>
</div>
<div class="paragraph">
<p><code>[ "HeapMemoryUsage", "NonHeapMemoryUsage" ]</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>path</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inner path for accessing the value of a complex value
(<a href="#paths">Paths</a>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>used</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following request fetches the number of active threads:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type": "read",
  "mbean": "java.lang:type=Threading",
  "attribute": "ThreadCount"
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="response-read"><a class="anchor" href="#response-read"></a>Read response</h4>
<div class="paragraph">
<p>The general format of the JSON response is described in
<a href="#responses">Responses</a> in detail.  A typical response for an
attribute read operation for a GET request with URL like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost:8080/jolokia/read/java.lang:type=Memory/HeapMemoryUsage</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "mbean": "java.lang:type=Memory",
    "attribute": "HeapMemoryUsage",
    "type": "read"
  },
  "history": [
    {
      "value": {
        "init": 524288000,
        "committed": 532676608,
        "max": 8334082048,
        "used": 78027104
      },
      "timestamp": 1702454713
    },
    ...
  ],
  "value": {
    "init": 524288000,
    "committed": 532676608,
    "max": 8334082048,
    "used": 86415712
  },
  "status": 200,
  "timestamp": 1702454822
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>Since Jolokia 2.1.0 we can use <code>includeRequest</code> parameter to tell Jolokia to exclude <code>request</code> field from the response.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>value</code> contains the response&#8217;s
value. For simple data types it is a scalar value, more complex
types are serialized into a JSON object. See
<a href="#serialization">Object serialization</a> for detail on object serialization.</p>
</div>
<div class="paragraph">
<p>For a read request of a single MBean with multiple attributes, the
returned value is a JSON object with the attribute names as keys
and their values as values. For example a request to
<code><a href="http://localhost:8080/jolokia/read/java.lang:type=Memory" class="bare">http://localhost:8080/jolokia/read/java.lang:type=Memory</a></code>
leads to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "mbean": "java.lang:type=Memory",
    "type": "read"
  },
  "value": {
    "ObjectPendingFinalizationCount": 0,
    "Verbose": false,
    "HeapMemoryUsage": {
      "init": 524288000,
      "committed": 532676608,
      "max": 8334082048,
      "used": 94804320
    },
    "NonHeapMemoryUsage": {
      "init": 7667712,
      "committed": 38928384,
      "max": -1,
      "used": 36905512
    },
    "ObjectName": {
      "objectName": "java.lang:type=Memory"
    }
  },
  "status": 200,
  "timestamp": 1702454894
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A request to a MBean pattern returns as value a JSON object,
with the MBean names as keys and as value another JSON object
with the attribute name as keys and the attribute values as
values. For example a request
<code><a href="http://localhost:8080/jolokia/read/java.lang:type=*/HeapMemoryUsage" class="bare">http://localhost:8080/jolokia/read/java.lang:type=*/HeapMemoryUsage</a></code>
returns something like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "mbean": "java.lang:type=*",
    "attribute": "HeapMemoryUsage",
    "type": "read"
  },
  "value": {
    "java.lang:type=Memory": {
      "HeapMemoryUsage": {
        "init": 524288000,
        "committed": 532676608,
        "max": 8334082048,
        "used": 103192928
      }
    }
  },
  "status": 200,
  "timestamp": 1702454978
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="write"><a class="anchor" href="#write"></a>Writing attributes (write)</h3>
<div class="paragraph">
<p>Writing an attribute is quite similar to reading one, except that the request takes an
additional <code>value</code> element.</p>
</div>
<div class="sect3">
<h4 id="get-write"><a class="anchor" href="#get-write"></a>GET write request</h4>
<div class="paragraph">
<p>Writing an attribute with a GET request, an URL with the following format has to be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;base url&gt;/write/&lt;mbean name&gt;/&lt;attribute name&gt;/&lt;value&gt;/&lt;inner path&gt;</pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. GET Write Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Part</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;mbean name&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MBean&#8217;s ObjectName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang:type=ClassLoading</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;attribute name&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of attribute to set</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Verbose</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;value&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The attribute name to value. The value must be serializable as described in
<a href="#serialization-request">Request parameter serialization</a>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;inner path&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inner path for accessing the parent object on which to set the value.
(See also <a href="#paths">Paths</a>). Note, that this is
<em>not</em> the path to the attribute itself,
but to the object carrying this attribute. With a given
path it is possible to deeply set a value on a complex
object.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For example, you can set the garbage collector to verbose mode by using
something like</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost:8080/jolokia/write/java.lang:type=Memory/Verbose/true</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="post-write"><a class="anchor" href="#post-write"></a>POST write request</h4>
<div class="paragraph">
<p>The keys which are evaluated for a POST write request are:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. POST Write Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>write</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mbean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MBean&#8217;s ObjectName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang:type=ClassLoading</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>attribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of attribute to set</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Verbose</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>value</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The attribute name to value. The value must be serializable as described in
<a href="#serialization-request">Request parameter serialization</a>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>path</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An optional inner path for specifying an inner object on which to set the
value. See <a href="#paths">Paths</a> for more on inner paths.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="response-write"><a class="anchor" href="#response-write"></a>Write response</h4>
<div class="paragraph">
<p>As response for a write operation the old attribute&#8217;s value is
returned. For a request</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost:8080/jolokia/write/java.lang:type=ClassLoading/Verbose/true</pre>
</div>
</div>
<div class="paragraph">
<p>you get the answer (supposed that verbose mode was switched
off for class loading at the time this request was sent)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "mbean": "java.lang:type=ClassLoading",
    "attribute": "Verbose",
    "type": "write",
    "value": "true"
  },
  "value": false,
  "status": 200,
  "timestamp": 1702455595
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>Since Jolokia 2.1.0 we can use <code>includeRequest</code> parameter to tell Jolokia to exclude <code>request</code> field from the response.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The response is quite similar to the read operation except for
the additional <code>value</code> element in the request
(and of course, the different <code>type</code>).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="exec"><a class="anchor" href="#exec"></a>Executing JMX operations (exec)</h3>
<div class="paragraph">
<p>With Jolokia we can also execute exposed JMX
operations with optional arguments. Just as when writing
attributes, Jolokia must be able to serialize the operation arguments. See
<a href="#serialization">Object serialization</a> for details. Execution of
overloaded methods is supported. The JMX specifications recommends
to avoid overloaded methods when exposing them via JMX, though.</p>
</div>
<div class="sect3">
<h4 id="get-exec"><a class="anchor" href="#get-exec"></a>GET exec request</h4>
<div class="paragraph">
<p>The format of an GET exec request is</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;base url&gt;/exec/&lt;mbean name&gt;/&lt;operation name&gt;/&lt;arg1&gt;/&lt;arg2&gt;/....</pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. GET Exec Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Part</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;mbean name&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MBean&#8217;s ObjectName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang:type=Threading</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;operation name&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of the operation to execute. If this is an overloaded method,
it is mandatory to provide a method signature as
well. A signature consist the fully qualified argument class
names or native types, separated by commas and enclosed with
parentheses. For calling a non-argument overloaded method use <code>()</code>
as signature.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>loadUsers(java.lang.String, int)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;arg1&gt;</code>, <code>&lt;arg2&gt;</code>, <code>&#8230;&#8203;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String representation for the arguments required to execute this
operation. Only certain data types can be used here as
described in <a href="#serialization-request">Request parameter serialization</a>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/true/true/</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following request will trigger a garbage collection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost:8080/jolokia/exec/java.lang:type=Memory/gc</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="post-exec"><a class="anchor" href="#post-exec"></a>POST exec request</h4>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. POST Exec Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>exec</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mbean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MBean&#8217;s ObjectName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang:type=Threading</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>operation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The operation to execute, optionally with a signature as
described above.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dumpAllThreads</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>arguments</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An array of arguments for invoking this operation. The value must be serializable as described in
<a href="#serialization-request">Request parameter serialization</a>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>[true, true]</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following request dumps all threads (along with locked
monitors and locked synchronizers, thats what the boolean
arguments are for):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type": "exec",
  "mbean": "java.lang:type=Threading",
  "operation": "dumpAllThreads(boolean, boolean)",
  "arguments": [ true, true ]
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="response-exec"><a class="anchor" href="#response-exec"></a>Exec response</h4>
<div class="paragraph">
<p>For an <code>exec</code> operation, the response
contains the return value of the
operation. <code>null</code> is returned if either the
operation returns a null value or the operation is declared as
void. A typical response for an URL like (mind that double quote (<code>"</code>) has to be encoded with <code>%22</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost:8080/jolokia/exec/java.util.logging:type=Logging/setLoggerLevel/%22%22/INFO</pre>
</div>
</div>
<div class="paragraph">
<p>looks like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "mbean": "java.util.logging:type=Logging",
    "arguments": [
      "",
      "INFO"
    ],
    "type": "exec",
    "operation": "setLoggerLevel"
  },
  "value": null,
  "status": 200,
  "timestamp": 1702456520
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>Since Jolokia 2.1.0 we can use <code>includeRequest</code> parameter to tell Jolokia to exclude <code>request</code> field from the response.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The return value get serialized as described in <a href="#serialization-request">Request parameter serialization</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search"><a class="anchor" href="#search"></a>Searching MBeans (search)</h3>
<div class="paragraph">
<p>With the Jolokia search operation the agent can be queried for
MBeans matching a given pattern. Searching will be performed on every
<code>MBeanServer</code> found by the agent.</p>
</div>
<div class="sect3">
<h4 id="get-search"><a class="anchor" href="#get-search"></a>GET search request</h4>
<div class="paragraph">
<p>The format of the search GET URL is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;base-url&gt;/search/&lt;pattern&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>This mode is used to query for certain MBean. It takes a single
argument <code>pattern</code> for
specifying the search parameter like in</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost:8080/jolokia/search/*:j2eeType=Servlet,*</pre>
</div>
</div>
<div class="paragraph">
<p>You can use patterns as described
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/ObjectName.html" class="externalLink" target="_blank" rel="noopener">here</a>,
i.e. it may contain wildcards like <code>*</code> and
<code>?</code>. The Mbean names matching the query
are returned as a list within the response.</p>
</div>
</div>
<div class="sect3">
<h4 id="post-search"><a class="anchor" href="#post-search"></a>POST search request</h4>
<div class="paragraph">
<p>A search POST request knows the following keys:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. POST Search Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>search</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mbean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The MBean pattern to search for</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang:*</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following request searches for all MBeans registered in the
domain <code>java.lang</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type": "search",
  "mbean": "java.lang:*"
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="response-search"><a class="anchor" href="#response-search"></a>Search response</h4>
<div class="paragraph">
<p>The answer is a list of MBean names which matches the pattern or an empty
list if there was no match.</p>
</div>
<div class="paragraph">
<p>For example, the request</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost:8888/jolokia/search/*:j2eeType=Servlet,*</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "mbean": "*:j2eeType=Servlet,*",
    "type": "search"
  },
  "value": [
    "Catalina:J2EEApplication=none,J2EEServer=none,WebModule=//localhost/manager,j2eeType=Servlet,name=Status",
    "Catalina:J2EEApplication=none,J2EEServer=none,WebModule=//localhost/manager,j2eeType=Servlet,name=JMXProxy",
    "Catalina:J2EEApplication=none,J2EEServer=none,WebModule=//localhost/manager,j2eeType=Servlet,name=jsp",
    "Catalina:J2EEApplication=none,J2EEServer=none,WebModule=//localhost/manager,j2eeType=Servlet,name=HTMLManager",
    "Catalina:J2EEApplication=none,J2EEServer=none,WebModule=//localhost/jolokia,j2eeType=Servlet,name=jsp",
    "Catalina:J2EEApplication=none,J2EEServer=none,WebModule=//localhost/,j2eeType=Servlet,name=default",
    "Catalina:J2EEApplication=none,J2EEServer=none,WebModule=//localhost/jolokia,j2eeType=Servlet,name=jolokia-agent",
    "Catalina:J2EEApplication=none,J2EEServer=none,WebModule=//localhost/,j2eeType=Servlet,name=jsp",
    "Catalina:J2EEApplication=none,J2EEServer=none,WebModule=//localhost/jolokia,j2eeType=Servlet,name=default",
    "Catalina:J2EEApplication=none,J2EEServer=none,WebModule=//localhost/manager,j2eeType=Servlet,name=Manager",
    "Catalina:J2EEApplication=none,J2EEServer=none,WebModule=//localhost/manager,j2eeType=Servlet,name=default"
  ],
  "status": 200,
  "timestamp": 1702458409
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>Since Jolokia 2.1.0 we can use <code>includeRequest</code> parameter to tell Jolokia to exclude <code>request</code> field from the response.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The returned MBean names are properly
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/ObjectName.html" class="externalLink" target="_blank" rel="noopener">quoted</a>
so that they can be directly used as
input for other requests.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="list"><a class="anchor" href="#list"></a>Listing MBeans (list)</h3>
<div class="paragraph">
<p>The list operation collects information about accessible
MBeans. This information includes the MBean names, their
attributes, operations and notifications along with type
information and description (as far as they are provided by the
MBean author which doesn&#8217;t seem to be often the case).</p>
</div>
<div class="sect3">
<h4 id="get-list"><a class="anchor" href="#get-list"></a>GET list request</h4>
<div class="paragraph">
<p>The GET request format for a Jolokia list request is</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;base-url&gt;/list/&lt;inner path&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>&lt;inner path&gt;</code>, as described in <a href="#paths">Paths</a>
specifies a subset of the complete response. You can
use this to select a specific domain, MBean or
attribute/operation. See the next section for the format of the
complete response.</p>
</div>
</div>
<div class="sect3">
<h4 id="post-list"><a class="anchor" href="#post-list"></a>POST list request</h4>
<div class="paragraph">
<p>A list POST request has the following keys:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. POST list Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>list</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>path</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Inner path for accessing the value of a subset of the complete list
<a href="#paths">Paths</a>).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.lang/type=Memory/attr</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following request fetches the information about the MBean <code>java.lang:type=Memory</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type": "list",
  "path": "java.lang/type=Memory"
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="response-list"><a class="anchor" href="#response-list"></a>List response</h4>
<div class="paragraph">
<p>The <code>value</code> has the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "&lt;domain&gt;": {
    "&lt;prop list&gt;": {
      "attr": {
        "&lt;attr name&gt;": {
          "type": "&lt;attribute type&gt;",
          "desc": "&lt;textual description of attribute&gt;",
          "rw": "true|false"
        },
        ...
      },
      "op": {
        "&lt;operation name&gt;": {
          "args": [
            {
              "type": "&lt;argument type&gt;",
              "name": "&lt;argument name&gt;",
              "desc": "&lt;textual description of argument&gt;"
            },
            ...
          ],
          "ret": "&lt;return type&gt;",
          "desc": "&lt;textual description of operation&gt;"
        },
        ...
      },
      "notif": {
        "&lt;notification type&gt;": {
            "name": "&lt;name&gt;",
            "desc": "&lt;desc&gt;",
            "types": [ "&lt;type1&gt;", "&lt;type2&gt;", ... ]
        },
        ...
      }
    },
    ...
  },
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>domain name</code> and the <code>property
list</code> together uniquely identify a single MBean. The
property list is in the so called <em>canonical
order</em>, i.e. in the form
<code>"&lt;key1&gt;=&lt;val1&gt;,&lt;key2&gt;=&lt;val2&gt;,.."</code>
where the keys are ordered alphabetically. Each MBean has zero
or more attributes and operations which can be reached in an
MBeans JSON object with the keys <code>attr</code> and
<code>op</code> respectively. Within these groups the
contained information is explained above in the schema and
consist of Java types for attributes, arguments and return
values, descriptive information and whether an attribute is
writable (<code>rw</code> == <code>true</code>) or
read-only.</p>
</div>
<div class="paragraph">
<p>As for reading attributes you can fetch a subset of this information using an
path. E.g a path of <code>domain/prop-list</code> would return the value for a single
bean only. For example, a request</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost:8080/jolokia/list/java.lang/type=Memory</pre>
</div>
</div>
<div class="paragraph">
<p>results in an answer</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "path": "java.lang/type=Memory",
    "type": "list"
  },
  "value": {
    "op": {
      "gc": {
        "args": [],
        "ret": "void",
        "desc": "gc"
      }
    },
    "notif": {
      "javax.management.Notification": {
        "types": [
          "java.management.memory.threshold.exceeded",
          "java.management.memory.collection.threshold.exceeded"
        ],
        "name": "javax.management.Notification",
        "desc": "Memory Notification"
      }
    },
    "attr": {
      "ObjectPendingFinalizationCount": {
        "rw": false,
        "type": "int",
        "desc": "ObjectPendingFinalizationCount"
      },
      "Verbose": {
        "rw": true,
        "type": "boolean",
        "desc": "Verbose"
      },
      "HeapMemoryUsage": {
        "rw": false,
        "type": "javax.management.openmbean.CompositeData",
        "desc": "HeapMemoryUsage"
      },
      "NonHeapMemoryUsage": {
        "rw": false,
        "type": "javax.management.openmbean.CompositeData",
        "desc": "NonHeapMemoryUsage"
      },
      "ObjectName": {
        "rw": false,
        "type": "javax.management.ObjectName",
        "desc": "ObjectName"
      }
    },
    "class": "sun.management.MemoryImpl",
    "desc": "Information on the management interface of the MBean"
  },
  "status": 200,
  "timestamp": 1702463340
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>Since Jolokia 2.1.0 we can use <code>includeRequest</code> parameter to tell Jolokia to exclude <code>request</code> field from the response.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_restrict_depth_of_the_returned_tree"><a class="anchor" href="#_restrict_depth_of_the_returned_tree"></a>Restrict depth of the returned tree</h4>
<div class="paragraph">
<p>The optional parameter <code>maxDepth</code> can be used
to restrict the depth of the return tree. Two value are
possible: A <code>maxDepth</code> of <code>1</code> restricts the
return value to a map with the JMX domains as keys, a
<code>maxDepth</code> of <code>2</code> truncates the map returned to
the domain names (first level) and the MBean&#8217;s properties
(second level). The final values of the maps don&#8217;t have any
meaning and are dummy values.</p>
</div>
</div>
<div class="sect3">
<h4 id="_extension_points"><a class="anchor" href="#_extension_points"></a>Extension points</h4>
<div class="paragraph">
<p>When returning <code>list()</code> results, Jolokia translates each MBean&#8217;s <code>javax.management.MBeanInfo</code> information into a JSON fragment. Standard fields of this fragment are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>class</code></p>
</li>
<li>
<p><code>desc</code></p>
</li>
<li>
<p><code>attr</code></p>
</li>
<li>
<p><code>op</code></p>
</li>
<li>
<p><code>notif</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These fields are added by default, built-in implementations of <code>org.jolokia.server.core.service.api.DataUpdater</code>.</p>
</div>
<div class="paragraph">
<p>Since Jolokia 2.1.0 we can now discover (using <code>/META-INF/jolokia/services</code>) additional services of <code>org.jolokia.server.core.service.api.DataUpdater</code> class which can be used to construct (or override) additional fields of MBean&#8217;s JSON information.<br>
Potential use-case may be information related to RBAC (Role-based Access Control).</p>
</div>
<div class="paragraph">
<p>One additional built-in <em>data updater</em> is <code>org.jolokia.service.jmx.handler.list.ListKeysDataUpdater</code> which can be enabled using <code>listKeys=true</code> processing parameter. We can use it to get additional <code>"keys"</code> MBeanInfo containing keys obtained from MBean&#8217;s ObjectName. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "path": "java.lang",
    "type": "list"
  },
  "value": {
    "name=G1 Survivor Space,type=MemoryPool": {
      "op": {
        "resetPeakUsage": {
          "args": [],
          "ret": "void",
          "desc": "resetPeakUsage"
        }
      },
      "keys": {
        "name": "G1 Survivor Space",
        "type": "MemoryPool"
      },
...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="optimized-response-list"><a class="anchor" href="#optimized-response-list"></a>Optimized List response</h4>
<div class="paragraph">
<p>Since Jolokia 2.1.0 we provide now <code>listCache</code> request processing parameter. When this parameter is set to <code>true</code> (it&#8217;s <code>false</code> for backward compatibility), <code>list()</code> response has different format - instead of a structure like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>domain:
  mbean:
    op:
    attr:
    notif:
    class:
    desc:
  ...
...</pre>
</div>
</div>
<div class="paragraph">
<p>we now have:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>"domains":
  domain:
    mbean: cache-key
    ...
  ...
"cache":
  cache-key:
    op:
    attr:
    notif:
    class:
    desc:
  ...</pre>
</div>
</div>
<div class="paragraph">
<p>Effectively:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>domain → mbean tree is moved 1 level down under <code>"domains"</code> field of <code>list()</code> response</p>
</li>
<li>
<p>mbean <em>may</em> contain known <code>op</code>, <code>attr</code>, &#8230;&#8203; fields, but may also be just a <em>cache key</em> pointing to <code>op</code>, <code>attr</code>, &#8230;&#8203; data stored under this <em>key</em> under <code>"cache"</code> field of <code>list()</code> response</p>
</li>
<li>
<p>the <em>cache keys</em> are generated by <code>org.jolokia.service.jmx.api.CacheKeyProvider</code> services/extensions</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="notification"><a class="anchor" href="#notification"></a>Using JMX notifications (notification) <mark>new in Jolokia 2</mark></h3>
<div class="paragraph">
<p>A new feature of Jolokia 2 is access to <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/Notification.html" class="externalLink" target="_blank" rel="noopener">JMX notifications</a>.
While reading/writing attributes, executing operations or listing/searching MBeans is implemented as single request-response operation, with notifications the flow of messages is more complex.</p>
</div>
<div class="paragraph">
<p>There are 4 groups of subcommands for Jolokia <code>notification</code> operation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Client registration/unregistration: <code>register</code> and <code>unregister</code> commands</p>
</li>
<li>
<p>Adding/removing/listing the listeners: <code>add</code>, <code>remove</code> and <code>list</code> commands</p>
</li>
<li>
<p>Ping (to refresh the registered client): <code>ping</code> command</p>
</li>
<li>
<p>Configuring a channel to a stream of notifications: <code>open</code> command</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="notification-registration"><a class="anchor" href="#notification-registration"></a>Client registration</h4>
<div class="paragraph">
<p>In order to subscribe to JMX notification, a <em>client</em> has to be registered, so Jolokia agent can be aware of the entities for which notifications should be collected and returned.</p>
</div>
<div class="paragraph">
<p>The GET URL for client registration has the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;base-url&gt;/notification/register</pre>
</div>
</div>
<div class="paragraph">
<p>The equivalend POST JSON payload is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type": "notification",
  "command": "register"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are no additional parameters in GET URL request or POST JSON payload.</p>
</div>
<div class="paragraph">
<p>The general format of the JSON response is described in
<a href="#responses">Responses</a> in detail. A typical response for client registration is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "type": "notification",
    "command": "register"
  },
  "value": {
    "backend": {
      "pull": {
        "maxEntries": 100,
        "store": "jolokia:type=NotificationStore,agent=192.168.0.221-21185-7e985ce9-servlet"
      },
      "sse": {
        "backChannel.contentType": "text/event-stream",
        "backChannel.encoding": "UTF-8"
      }
    },
    "id": "d77475dc-c7a7-4f71-b988-52b7f0252ca3"
  },
  "status": 200,
  "timestamp": 1702464211
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>Since Jolokia 2.1.0 we can use <code>includeRequest</code> parameter to tell Jolokia to exclude <code>request</code> field from the response.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>value</code> field in the response contains two important fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id</code> is an identifier of registered client, which is used in other notification-related Jolokia operations</p>
</li>
<li>
<p><code>backend</code> is a collection of available <em>backends</em> (See more in <a href="#accessing-notification-stream">Accessing notification stream</a>). Jolokia 2 supports <code>sse</code> and <code>pull</code> backends. Other backends (like <code>websocket</code>) may be added in the future.</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>pull</code> backend</dt>
<dd>
<p>In this implementation, notifications are collected within the Jolokia Agent and client has to <em>fetch</em> (<em>pull</em>) them by calling <code>pull</code> operation on <code>jolokia:type=NotificationStore</code> MBean.</p>
</dd>
<dt class="hdlist1"><code>sse</code> backend</dt>
<dd>
<p>In this mode <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events" class="externalLink" target="_blank" rel="noopener">Server Sent Events</a> are used (See <a href="https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events" class="externalLink" target="_blank" rel="noopener">WhatWG specification</a>).</p>
</dd>
</dl>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="notification-unregistration"><a class="anchor" href="#notification-unregistration"></a>Client unregistration</h4>
<div class="paragraph">
<p>In order to unsubscribe from Jolokia notification mechanism, an existing client has to be unregistered, by passing an existing client ID.</p>
</div>
<div class="paragraph">
<p>The GET URL for client registration has the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;base-url&gt;/notification/unregister/&lt;client-id&gt;</pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. GET Unregistration Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Part</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;client-id&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Client ID of previously registered client</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>d77475dc-c7a7-4f71-b988-52b7f0252ca3</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The equivalend POST JSON payload is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type": "notification",
  "command": "unregister",
  "client": "&lt;client-id&gt;"
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 11. POST Unregistration Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>notification</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>command</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>unregister</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>client</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Client ID of previously registered client</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>d77475dc-c7a7-4f71-b988-52b7f0252ca3</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A typical response for client unregistration is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "client": "d77475dc-c7a7-4f71-b988-52b7f0252ca3",
    "type": "notification",
    "command": "unregister"
  },
  "value": null,
  "status": 200,
  "timestamp": 1702464913
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The returned <code>value</code> is simply <code>null</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="notification-add"><a class="anchor" href="#notification-add"></a>Adding a notification listener</h4>
<div class="paragraph">
<p>Having registered a notification client, we can now use notification listeners. The underlying JMX call is <code>javax.management.MBeanServerConnection.addNotificationListener()</code> method which requires several parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ObjectName</code>: The name of the MBean on which the listener should be added</p>
</li>
<li>
<p><code>NotificationListener</code>: The listener object which will handle the notifications emitted by the registered MBean.</p>
</li>
<li>
<p><code>NotificationFilter</code>: The filter object. It can be used to filter notifications specific to a given MBean</p>
</li>
<li>
<p><code>Object</code>: any <em>handback</em> object which will be passed to a listener when notification arrives - this is how Jolokia can get back to the client which added a JMX notification listener.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The GET URL for adding a notification listener has the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;base-url&gt;/notification/add/&lt;client-id&gt;/&lt;mode&gt;/&lt;mbean name&gt;/&lt;filter1&gt;,.../&lt;config&gt;/&lt;handback&gt;</pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 12. GET AddNotification Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Part</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;client-id&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Client ID of previously registered client</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>d77475dc-c7a7-4f71-b988-52b7f0252ca3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;mode&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">One of supported modes of notification handling: <code>pull</code> or <code>sse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pull</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;mbean name&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/ObjectName.html" class="externalLink" target="_blank" rel="noopener">ObjectName</a>
of the MBean for which we&#8217;re registering a notification listener</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JMImplementation:type=MBeanServerDelegate</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;filter1&gt;</code>, <code>&lt;filter2&gt;</code>, &#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comma-separated list notifications we&#8217;re interested in (and supported by given <code>&lt;mbean name&gt;</code>). If we want all
notifications, a space (<code>%20</code>) or empty string (<code>%22%22</code>) can be passed. See filter rules in <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/NotificationFilterSupport.html#enableType(java.lang.String)" class="externalLink" target="_blank" rel="noopener">NotificationFilterSupport.enableType() Javadoc</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JMX.mbean.registered</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;config&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This optional part can be passed to a notification listener as JSON object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{"priority":"normal"}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;handback&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This optional part can be passed to a notification listener and will be returned for each related notification. In GET request it can only be a String value.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>my-correlation-ID-1234</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The equivalent POST JSON payload is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type": "notification",
  "command": "add",
  "client": "1cddf91c-423e-46d8-ac9a-2eb6d8b213c7",
  "mode": "pull",
  "mbean": "JMImplementation:type=MBeanServerDelegate",
  "filter": [],
  "handback": "id-1234"
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 13. POST AddNotification Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>notification</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>command</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>add</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>client</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Client ID of previously registered client</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>d77475dc-c7a7-4f71-b988-52b7f0252ca3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">One of supported modes of notification handling: <code>pull</code> or <code>sse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pull</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mbean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/ObjectName.html" class="externalLink" target="_blank" rel="noopener">ObjectName</a>
of the MBean for which we&#8217;re registering a notification listener</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JMImplementation:type=MBeanServerDelegate</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>filter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A JSON array of notification notifications we&#8217;re interested in (and supported by given <code>mbean</code>). If we want all
notifications, a space (<code>%20</code>) or empty string (<code>%22%22</code>) can be passed. See filter rules in <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/NotificationFilterSupport.html#enableType(java.lang.String)" class="externalLink" target="_blank" rel="noopener">NotificationFilterSupport.enableType() Javadoc</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>[ "JMX.mbean.registered", "JMX.mbean.unregistered" ]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>config</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This optional part can be passed to a notification listener as JSON object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{"priority":"normal"}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>handback</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This optional part can be passed to a notification listener and will be returned for each related notification.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "my-correlation-ID": "1234" }</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A typical response for added notification listener is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "mode": "pull",
    "mbean": "JMImplementation:type=MBeanServerDelegate",
    "client": "1cddf91c-423e-46d8-ac9a-2eb6d8b213c7",
    "type": "notification",
    "handback": "id-1234",
    "command": "add"
  },
  "value": "2",
  "status": 200,
  "timestamp": 1702472334
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The returned <code>value</code> is a <em>handle</em> to the added listener, required when removing the listener in the future.</p>
</div>
</div>
<div class="sect3">
<h4 id="notification-list"><a class="anchor" href="#notification-list"></a>Checking existing notification listeners</h4>
<div class="paragraph">
<p>To check existing listener registrations for previously registered client, we can use <code>list</code> command of <code>notification</code> operation.</p>
</div>
<div class="paragraph">
<p>The GET URL for listing client listener registrations has the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;base-url&gt;/notification/list/&lt;client-id&gt;</pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 14. GET Unregistration Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Part</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;client-id&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Client ID of previously registered client</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>d77475dc-c7a7-4f71-b988-52b7f0252ca3</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The equivalend POST JSON payload is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type": "notification",
  "command": "list",
  "client": "&lt;client-id&gt;"
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 15. POST Unregistration Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>notification</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>command</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>list</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>client</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Client ID of previously registered client</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>d77475dc-c7a7-4f71-b988-52b7f0252ca3</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A typical response for listing the registrations is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "client": "1cddf91c-423e-46d8-ac9a-2eb6d8b213c7",
    "type": "notification",
    "command": "list"
  },
  "value": {
    "1": {
      "mbean": "JMImplementation:type=MBeanServerDelegate",
      "handback": "id-1234"
    },
    "2": {
      "filter": [
        "java.management.memory.threshold.exceeded"
      ],
      "mbean": "java.lang:type=Memory"
    }
  },
  "status": 200,
  "timestamp": 1702472848
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The returned <code>value</code> is a collection of listener registrations with their details, keyed by <em>handle</em> id.</p>
</div>
</div>
<div class="sect3">
<h4 id="notification-remove"><a class="anchor" href="#notification-remove"></a>Removing a notification listener</h4>
<div class="paragraph">
<p>When a notification listener for a given client is no longer needed, we can remove using <code>remove</code> command of <code>notification</code> operation.</p>
</div>
<div class="paragraph">
<p>The GET URL for removing client listener registrations has the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;base-url&gt;/notification/remove/&lt;client-id&gt;/&lt;handle&gt;</pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 16. GET Unregistration Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Part</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;client-id&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Client ID of previously registered client</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>d77475dc-c7a7-4f71-b988-52b7f0252ca3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;handle&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <em>handle</em> of previously added listener</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The equivalend POST JSON payload is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type": "notification",
  "command": "remove",
  "client": "&lt;client-id&gt;",
  "handle": "&lt;handle-id&gt;"
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 17. POST Unregistration Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>notification</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>command</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>remove</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>client</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Client ID of previously registered client</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>d77475dc-c7a7-4f71-b988-52b7f0252ca3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>handle</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <em>handle</em> of previously added listener</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A typical response for listing the registrations is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "client": "1cddf91c-423e-46d8-ac9a-2eb6d8b213c7",
    "handle": "1",
    "type": "notification",
    "command": "remove"
  },
  "value": null,
  "status": 200,
  "timestamp": 1702473703
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The returned <code>value</code> is simply <code>null</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="accessing-notification-stream"><a class="anchor" href="#accessing-notification-stream"></a>Accessing notification stream</h4>
<div class="paragraph">
<p>When a listener is added for a client (see <a href="#notification-add">Adding a notification listener</a>), a mode indicates a desired <em>notification backend</em>.</p>
</div>
<div class="paragraph">
<p>For <code>pull</code> backend, there&#8217;s actually no <em>back channel</em> over which we can receive the notifications. Instead we should be
calling an MBean operation on an MBean representing the backend. The details are available when client was first registered:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">"backend": {
  "pull": {
    "maxEntries": 100,
    "store": "jolokia:type=NotificationStore,agent=192.168.0.221-21185-7e985ce9-servlet"
  },
  ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we want to access notifications collected in <code>pull</code> backend, we have to call <code>org.jolokia.service.notif.pull.PullNotificationStoreMBean.pull(String pClientId, String pHandle)</code> MBean operation on <code>jolokia:type=NotificationStore,agent=&lt;agent-id&gt;</code> MBean which can be done with Jolokia <code>exec</code> operation.</p>
</div>
<div class="paragraph">
<p>For example, having registered a notification listener for <code>JMImplementation:type=MBeanServerDelegate</code> MBean, we can get notified about MBean registrations/unregistrations. Accessing the pull notification store can be done with <code>exec</code> operation like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">$ curl -s -u jolokia:jolokia 'http://localhost:8080/jolokia/exec/jolokia:type=NotificationStore,agent=192.168.0.221-21185-7e985ce9-servlet/pull(java.lang.String,java.lang.String)/1cddf91c-423e-46d8-ac9a-2eb6d8b213c7/2' | jq .
{
  "request": {
    "mbean": "jolokia:agent=192.168.0.221-21185-7e985ce9-servlet,type=NotificationStore",
    "arguments": [
      "1cddf91c-423e-46d8-ac9a-2eb6d8b213c7",
      "2"
    ],
    "type": "exec",
    "operation": "pull(java.lang.String,java.lang.String)"
  },
  "value": {
    "dropped": 0,
    "handle": "2",
    "handback": "id-1234",
    "notifications": [
      {
        "timeStamp": 1702473332222,
        "sequenceNumber": 248,
        "userData": null,
        "mBeanName": {
          "objectName": "Catalina:name=HttpRequest3,type=RequestProcessor,worker=\"http-nio-8080\""
        },
        "source": {
          "objectName": "JMImplementation:type=MBeanServerDelegate"
        },
        "message": "",
        "type": "JMX.mbean.registered"
      },
      {
        "timeStamp": 1702473390407,
        "sequenceNumber": 249,
        "userData": null,
        "mBeanName": {
          "objectName": "Catalina:J2EEApplication=none,J2EEServer=none,WebModule=//localhost/,name=jsp,type=JspMonitor"
        },
        "source": {
          "objectName": "JMImplementation:type=MBeanServerDelegate"
        },
        "message": "",
        "type": "JMX.mbean.unregistered"
      },
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>On the other hand, <code>sse</code> notification store works differently. Here&#8217;s the information received during client registration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">"sse": {
  "backChannel.contentType": "text/event-stream",
  "backChannel.encoding": "UTF-8"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of providing us with Mbean name to access when needed (<em>pull</em> the notifications out if it by calling an MBean operation), <code>sse</code> backend needs a channel associated with client connection. This is where <code>open</code> command for <code>notification</code> operation comes into play.</p>
</div>
<div class="paragraph">
<p>When calling <code>open</code> command for <code>sse</code> backed notifications, the request (<code>HttpServletRequest</code>) is put into <a href="https://jakarta.ee/specifications/servlet/5.0/jakarta-servlet-spec-5.0#asynchronous-processing" class="externalLink" target="_blank" rel="noopener">asynchronous mode</a> and connection is not closed.</p>
</div>
<div class="paragraph">
<p>The GET URL for openning a backend channel for notification acces is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;base-url&gt;/notification/open/&lt;client-id&gt;/&lt;mode&gt;</pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 18. GET Open Notification Channel Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Part</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;client-id&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Client ID of previously registered client</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>d77475dc-c7a7-4f71-b988-52b7f0252ca3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;mode&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A mode of notification delivery. Only <code>sse</code> is useful.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sse</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The equivalend POST JSON payload is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type": "notification",
  "command": "open",
  "client": "&lt;client-id&gt;",
  "mode": "&lt;mode&gt;"
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 19. POST Open Notification Channel Request</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>notification</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>command</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>open</code></strong></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>client</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Client ID of previously registered client</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>d77475dc-c7a7-4f71-b988-52b7f0252ca3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A mode of notification delivery. Only <code>sse</code> is useful.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sse</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The notifications are returned to the client as they&#8217;re delivered from JMX. Here&#8217;s a sample interaction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -i -u jolokia:jolokia 'http://localhost:8080/jolokia/notification/open/c72e2f07-e5ec-47a0-b9b4-3036b16614a0/sse'
HTTP/1.1 200
Cache-Control: private
Content-Type: text/event-stream;charset=UTF-8
Transfer-Encoding: chunked
Date: Wed, 13 Dec 2023 15:49:39 GMT

:
:
:
:
:
id: 363
data: {"dropped":0,"handle":"2","handback":null,"notifications":[{"timeStamp":1702482067031,"sequenceNumber":363,"userData":null,"mBeanName":{"objectName":"Catalina:J2EEApplication=none,J2EEServer=none,WebModule=\/\/localhost\/,name=jsp,type=JspMonitor"},"source":{"objectName":"JMImplementation:type=MBeanServerDelegate"},"message":"","type":"JMX.mbean.unregistered"}]}

id: 364
data: {"dropped":0,"handle":"2","handback":null,"notifications":[{"timeStamp":1702482067031,"sequenceNumber":364,"userData":null,"mBeanName":{"objectName":"Catalina:J2EEApplication=none,J2EEServer=none,WebModule=\/\/localhost\/,j2eeType=Filter,name=Tomcat WebSocket (JSR356) Filter"},"source":{"objectName":"JMImplementation:type=MBeanServerDelegate"},"message":"","type":"JMX.mbean.unregistered"}]}</pre>
</div>
</div>
<div class="paragraph">
<p>The returned data is structured according to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events"><code>text/event-stream</code> Mime type</a>. <code>id</code> and <code>data</code> fields are used, where <code>id</code> matches the <code>sequenceNumber</code> from the JSON payload.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="version"><a class="anchor" href="#version"></a>Getting the agent version (version)</h3>
<div class="paragraph">
<p>The Jolokia command <code>version</code> returns the version of
the Jolokia agent along with the protocol version.</p>
</div>
<div class="sect3">
<h4 id="get-version"><a class="anchor" href="#get-version"></a>GET version request</h4>
<div class="paragraph">
<p>The GET URL for a version request has the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;base-url&gt;/version</pre>
</div>
</div>
<div class="paragraph">
<p>For GET request the <code>version</code> part can be
omitted since this is the default command if no command is
provided as path info.</p>
</div>
</div>
<div class="sect3">
<h4 id="post-version"><a class="anchor" href="#post-version"></a>POST version request</h4>
<div class="paragraph">
<p>A version POST request has only a single key
<code>type</code> which has to be set to
<strong><code>version</code></strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="response-version"><a class="anchor" href="#response-version"></a>Version response</h4>
<div class="paragraph">
<p>The response value for a version request looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "request": {
    "type": "version"
  },
  "value": {
    "agent": "2.4.0",
    "protocol": "7.2",
    "details": {
      "agent_version": "2.4.0",
      "agent_id": "192.168.0.221-21185-5ce94d31-servlet",
      "server_product": "tomcat",
      "server_vendor": "Apache",
      "server_version": "10.1.16",
      "secured": true,
      "url": "http://192.168.0.221:8080/jolokia"
    },
    "id": "192.168.0.221-21185-5ce94d31-servlet",
    "config": {
      "maxDepth": "15",
      "discoveryEnabled": "false",
      "agentId": "192.168.0.221-21185-5ce94d31-servlet",
      "maxCollectionSize": "0",
      "debug": "false",
      "canonicalNaming": "true",
      "historyMaxEntries": "10",
      "serializeException": "false",
      "includeStackTrace": "false",
      "maxObjects": "0",
      "detectorOptions": "{}",
      "debugMaxEntries": "100"
    },
    "info": {
      "proxy": {},
      "jmx": {}
    }
  },
  "status": 200,
  "timestamp": 1702482830
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>Since Jolokia 2.1.0 we can use <code>includeRequest</code> parameter to tell Jolokia to exclude <code>request</code> field from the response.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p><code>protocol</code> in the response value contains the
protocol version used, <code>agent</code> is the version of
the Jolokia agent. See <a href="#versions">Jolokia protocol versions</a> for the various
protocol versions and the interoperability. If the agent is able
to detect the server, additional meta information about this
server is returned (i.e. the product name, the vendor and
optionally some extra information added by the server detector).</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="processing-parameters"><a class="anchor" href="#processing-parameters"></a>Processing parameters</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jolokia operations can be influenced by so-called
<em>processing parameters</em>. These parameters
are provided differently for POST and GET requests.</p>
</div>
<div class="paragraph">
<p>For GET request, the processing parameter are given as normal
query parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;GET request URL&gt;?param1=value1&amp;param2=value2&amp;...</pre>
</div>
</div>
<div class="paragraph">
<p>For example the request</p>
</div>
<div class="listingblock">
<div class="content">
<pre>http://localhost:8080/jolokia/list?maxObjects=100</pre>
</div>
</div>
<div class="paragraph">
<p>will limit the response to at max 100 values.</p>
</div>
<div class="paragraph">
<p>POST request take the processing instructions within the
JSON request below the key <code>config</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type" : "list",
  "config" : {
    "maxObjects" : 100
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a POST request carries also query parameters in the URL, these processing parameters
are merged with the ones given within the request body. Configuration options given in the
request body take precedence over the ones given as query parameters.</p>
</div>
<div class="paragraph">
<p>The list of known processing parameters is:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>maxDepth</code></dt>
<dd>
<p>Maximum depth of the tree traversal into a bean&#8217;s
properties. The maximum value as configured in the
agent&#8217;s configuration is a hard limit
and cannot be exceeded by a query parameter.</p>
</dd>
<dt class="hdlist1"><code>maxCollectionSize</code></dt>
<dd>
<p>For collections (lists, maps) this is the maximum size.</p>
</dd>
<dt class="hdlist1"><code>maxObjects</code></dt>
<dd>
<p>Number of objects to visit in total. A hard limit
can be configured in the agent&#8217;s configuration.</p>
</dd>
<dt class="hdlist1"><code>serializeLong</code></dt>
<dd>
<p>How to serialize long values in the JSON response: <code>number</code> or <code>string</code>.
The default <code>number</code> simply serializes longs as numbers in JSON.
If set to <code>string</code>, longs are serialized as strings.
It can be useful when a JavaScript client consumes the JSON response,
because numbers greater than the max safe integer don&#8217;t retain their precision
in JavaScript.
<strong>Added since Jolokia 2.0.3</strong></p>
</dd>
<dt class="hdlist1"><code>ignoreErrors</code></dt>
<dd>
<p>If set to <code>true</code>, a Jolokia operation will not return an
error if an JMX operation fails, but includes the
exception message as value. This is useful for e.g. the
read operation when requesting multiple attributes'
values. Default: <code>false</code></p>
</dd>
<dt class="hdlist1"><code>mimeType</code></dt>
<dd>
<p>The MIME type to return for the response. By default,
this is <code>text/plain</code>, but it can be
useful for some tools to change it to
<code>application/json</code>. Init parameters can
be used to change the default mime type.
Only <code>text/plain</code> and <code>application/json</code> are allowed.
For any other value Jolokia will fallback to <code>text/plain</code>.</p>
</dd>
<dt class="hdlist1"><code>includeRequest</code></dt>
<dd>
<p>A flag (defaults to <code>true</code>) which controls whether the incoming
request should be included in the response (under <code>request</code> key).<br>
When <code>false</code>, bulk responses have to be correlated with requests by matching
the requests using index number - responses come in the same order as requests.<br>
<strong>Added since Jolokia 2.1.0</strong></p>
</dd>
<dt class="hdlist1"><code>listKeys</code></dt>
<dd>
<p>A flag (defaults to <code>false</code>) to specify whether the response object for <code>list()</code> operation should contain <code>keys</code> field
that lists all the keys obtained from each <code>javax.management.ObjectName</code> of the response.
This may save you time parsing the name yourself.<br>
<strong>Added since Jolokia 2.1.0</strong></p>
</dd>
<dt class="hdlist1"><code>listCache</code></dt>
<dd>
<p>A flag (defaults to <code>false</code>) to enable <em>optimized list response</em>.<br>
With this flag enabled, <code>list()</code> operation returns a bit different structure (that&#8217;s why we&#8217;ve upgraded protocol version to <code>8.0</code>) where some MBeans may <em>point to</em> cached, shared MBeanInfo JSON fragment. This heavily decreases the size of <code>list()</code> response.
<strong>Added since Jolokia 2.1.0</strong></p>
</dd>
<dt class="hdlist1"><code>canonicalNaming</code></dt>
<dd>
<p>Defaults to <code>true</code> to return the canonical format of property lists.
If set to <code>false</code> then the default unsorted property list is returned.</p>
</dd>
<dt class="hdlist1"><code>includeStackTrace</code></dt>
<dd>
<p>If set to <code>true</code>, then in case of an error the stack trace is included.
With <code>false</code> no stack trace will be returned, and when this parameter
is set to <code>runtime</code> only for RuntimeExceptions a stack trace is put into
the error response. Default is <code>false</code> if not set otherwise in the global
agent configuration.</p>
</dd>
<dt class="hdlist1"><code>serializeException</code></dt>
<dd>
<p>If this parameter is set to <code>true</code> then a serialized version of the
exception is included in an error response. This value
is put under the key <code>error_value</code> in
the response value. By default this is set to
<code>false</code> except when the agent global
configuration option is configured otherwise.</p>
</dd>
<dt class="hdlist1"><code>ifModifiedSince</code></dt>
<dd>
<p>If this parameter is given, its value is interpreted as epoch time (seconds since 1.1.1970) and
if the requested value did not change since this time, an empty response (with no <code>value</code>)
is returned and the response status code is set to 304 ("Not modified"). This
option is currently only supported for <code>list</code> requests. The time value can be
extracted from a previous' response <code>timestamp</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="serialization"><a class="anchor" href="#serialization"></a>Object serialization</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jolokia has some object serialization facilities in order to
convert complex Java data types to JSON and vice
versa. Serialization works in both ways in requests and
responses, but the capabilities differ.</p>
</div>
<div class="paragraph">
<p>Complex data types returned from the agent can be serialized
completely into a JSON value object. It can detect cycles in
the object graph and provides a way to limit the depth of
serialization. For certain types (like
<code>File</code> or
<code>ObjectName</code>) it uses a service <code>org.jolokia.service.serializer.json.simplifier.SimplifierAccessor</code> to not
expose internal and redundant information.</p>
</div>
<div class="paragraph">
<p>Object values used for values in
<code>write</code> operations and arguments in
<code>exec</code>, type support is limited to a
handful of data types.</p>
</div>
<div class="sect2">
<h3 id="serialization-response"><a class="anchor" href="#serialization-response"></a>Response value serialization</h3>
<div class="paragraph">
<p>Jolokia can serialize any object into a JSON representation
when generating the response. It uses some specific
converters for certain well known data type with a generic
bean converter as fallback.</p>
</div>
<div class="paragraph">
<p>The following types are directly supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Arrays and <code>java.util.List</code> are converted to JSON arrays</p>
</li>
<li>
<p><code>java.util.Map</code> gets
converted into a JSON object. Note, however, that JSON
Object keys are <em>always strings</em>.</p>
</li>
<li>
<p>Enums are converted to their canonical name<sup class="footnote" id="_footnote_enum-serial-jboss">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup>.</p>
</li>
<li>
<p><code>javax.management.openmbean.CompositeData</code>
is converted in a JSON object, with the keys taken from
the `CompositeData&#8217;s key set and
the value are its values.</p>
</li>
<li>
<p><code>javax.management.openmbean.TabularData</code>
is serialized differently depending on its internal
structure. See below for a detailed explanation of this
serialization mechanism including examples.</p>
</li>
<li>
<p><code>java.lang.Class</code> is converted to
a JSON object with keys <code>name</code> (the class
name) and <code>interfaces</code> (the implemented
interfaces, if any)</p>
</li>
<li>
<p><code>java.io.File</code> becomes a JSON
object with keys <code>name</code> (file name),
<code>modified</code> (date of last modification),
<code>length</code> (file size in bytes),
<code>directory</code> (whether the file is a directory),
<code>canonicalPath</code> (the canonical path)
and <code>exists</code>.</p>
</li>
<li>
<p><code>javax.management.ObjectName</code> is
converted into a JSON object with the single key
<code>objectName</code>.</p>
</li>
<li>
<p><code>java.net.URL</code> becomes a JSON
object with the key <code>url</code> containing
the URL as String.</p>
</li>
<li>
<p><code>java.util.Date</code> is represented by default in
an ISO-8601 format. When used with a path
<code>time</code> the milliseconds since 1.1.1970
00:00 UTC are returned.<br>
Since <strong>Jolokia 2.1.0</strong> the format for date/time serialization is configurable
and we also support <code>java.util.Calendar</code> and <code>java.time.Temporal</code> implementations.</p>
</li>
<li>
<p><code>org.w3c.dom.Element</code> is translated
into a JSON object with the properties
<code>name</code>, <code>value</code> and
<code>hasChildNodes</code>.</p>
</li>
<li>
<p><code>java.math.BigInteger</code> becomes a JSON
object with the key <code>bigint</code> containing
the big integer value as String.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Primitive and simple types (like String) are
directly converted into their string presentation. All
objects not covered by the list above are serialized in JSON
objects, where the keys are the public bean properties of
the object and the values are serialized (recursively) as
described.</p>
</div>
<div class="paragraph">
<p><code>TabularData</code> serialization depends on
the type of the index. It is serialized into one or multiple
nested JSON objects where the keys are derived from its
<code>TabularType.indexNames()</code>. If there is
a single valued index with a simple type (i.e. an instance of
<code>javax.management.openmbean.SimpleType</code>),
the index&#8217;s value is the key and a
<code>TabularData</code>'s row (which in turn is a
<code>CompositeData</code>) is a map. With multi
valued, simple typed, keys, the map is nested (first level:
first index&#8217;s value, second level: second index&#8217;s value and
so on). For the serialization of
<code>TabularData</code> resulting from a
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/MXBean.html" class="externalLink" target="_blank" rel="noopener">MXBean</a>
translation for maps, see
<a href="#serialization-mxbean">Jolokia and MXBeans</a>. If any of the declared
index keys of a <code>TabularData</code> is a
complex type (i.e. not a <code>SimpleType</code>),
then this simple serialization into maps of maps is not
possible anymore, since for JSON, map keys must be simple
types. In this case, a more generic serialization is used in
which case an JSON object with two keys is returned:
<code>indexNames</code> is an array with the
<code>TabularData</code>'s indexes as names and
<code>values</code> is the array containing the
values as JSON object with the corresponding rows as values
(including the indexes).</p>
</div>
<div class="paragraph">
<p>For example if there is a single valued key
<code>key</code>, then the returned JSON looks like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "mykey1" : { "key" : "mkey1", "item" : "value1", .... },
  "mykey2" : { "key" : "mkey2", "item" : "value2", .... },
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For multi valued keys of simple open types
(i.e. <code>TabularType.getIndexNames()</code>)
is a list with more than one element but all of them are
simple types), the returned JSON structure looks like (index
names here are <code>key</code> and
<code>innerkey</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "mykey1" : {
    "myinner1" : { "key" : "mkey1", "innerkey" : "myinner1", "item" : "value1", .... },
    "myinner2" : { "key" : "mkey1", "innerkey" : "myinner2", "item" : "value1", .... },
    ....
  },
  "mykey2" : {
    "second1" : { "key" : "mkey2", "innerkey" : "second1", "item" : "value1", .... },
    "second2" : { "key" : "mkey2", "innerkey" : "second2", "item" : "value1", .... },
    ....
  },
  ....
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If keys are used, which themselves are complex objects (like
<code>CompositeData</code>), this hierarchical map structure can not be
used. In this case an object with two keys is returned:
<code>indexNames</code> holds the name of the key
index and <code>values</code> is an array of all
rows which are represented as JSON objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "indexNames" : [ "key", "innerkey" ],
  "values" : [
    { "key" : "mykey1", "innerkey" : { "name" : "a", "number" : 4711 }, "item" : "value1", .... },
    { "key" : "mykey2", "innerkey" : { "name" : "b", "number" : 815 }, "item" : "value2", .... },
    ...
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Beside this special behaviour for
<code>TabularData</code>, serialization can be
influenced by certain processing parameters given with the
request (see
<a href="#processing-parameters">Processing parameters</a>). I.e. the recursive
process of JSON serialization can be stopped when the data
set gets too large. Self and other circular references are
detected, too. If this happen, special values indicate the
truncation of the generated JSON object.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>[this]</code></dt>
<dd>
<p>This label is used when a property contains a self reference</p>
</dd>
<dt class="hdlist1"><code>[Depth limit &#8230;&#8203;. ]</code></dt>
<dd>
<p>When a depth limit is used or the hard depth limit
is exceeded, this label contains a string
representation of the next object one level deeper.
(see <a href="#processing-parameters">Processing parameters</a>,
parameter <code>maxDepth</code>)</p>
</dd>
<dt class="hdlist1"><code>[Reference &#8230;&#8203;. ]</code></dt>
<dd>
<p>If during the traversal an object is visited a second time, this label is
used in order to break the cycle.</p>
</dd>
<dt class="hdlist1"><code>[Object limit exceeded]</code></dt>
<dd>
<p>The total limit of object has been exceeded and hence
the object are not deserialized further.  (see
<a href="#processing-parameters">Processing parameters</a>, parameters
<code>maxCollectionSize</code> and
<code>maxObjects</code>)</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="serialization-request"><a class="anchor" href="#serialization-request"></a>Request parameter serialization</h3>
<div class="paragraph">
<p>Serialization in the upstream direction (i.e. when sending
values for <code>write</code> operations or arguments
for <code>exec</code> operations) differs from
from the object serializaton as used as response values
which is described in
<a href="#serialization-response">Response value serialization</a>. Not all types are
supported for upstream serialization <sup class="footnote" id="_footnote_upstream-serialization-comment">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup>
and the capabilities differ also for POST and GET requests.
<code>GET</code> upstream serialization is limited to
basic types and simple arrays. POST requests on the other
support a much large set of types, including the
serialization of <code>Map</code>s,
<code>List</code>s and all
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/openmbean/OpenType.html" class="externalLink" target="_blank" rel="noopener">Open Types</a>.</p>
</div>
<div class="sect3">
<h4 id="_get_request_values"><a class="anchor" href="#_get_request_values"></a>GET request values</h4>
<div class="paragraph">
<p>Since parameters get encoded in the URL for GET request,
only the following types can used for values and arguments
in <code>write</code> and
<code>exec</code> requests:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>String</p>
</li>
<li>
<p>Integer / int</p>
</li>
<li>
<p>Long / long</p>
</li>
<li>
<p>Byte / byte</p>
</li>
<li>
<p>Short / short</p>
</li>
<li>
<p>Float / float</p>
</li>
<li>
<p>Double / double</p>
</li>
<li>
<p>BigDecimal / BigInteger</p>
</li>
<li>
<p>char</p>
</li>
<li>
<p>Boolean / boolean</p>
</li>
<li>
<p>Date</p>
</li>
<li>
<p>java.time.Instant, java.time.OffsetDateTime, java.time.ZonedDateTime (since <strong>2.1.0</strong>)</p>
</li>
<li>
<p>URL</p>
</li>
<li>
<p>Enums (whose type is accessible to the agent, see below)</p>
</li>
<li>
<p>Any type, that is accessible to the agent, and
has a public constructor with one String parameter</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The serialized value is simply the string representation
of those types. Dates can be set either by an long value
(epoch milliseconds) or with a string value (ISO-8601
format). Arrays of the given types are serialized as a
comma separated list.
When setting <code>java.time</code> values, we handle serialization of these <code>Temporal</code> instances
which support <code>ChronoField.INSTANT_SECONDS</code>, so full information (date, time, zone and nanoseconds) can
be sent to the server.
When deserializing <code>java.time</code> values, we use configurable DateTime format (both for <code>java.util.Date</code>) and
for new (since JDK 8) <code>java.time</code> classes.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The array support is somewhat limited since it makes a
native split on commas. It does not yet take into account
any quoting or escaping. For a much safer way to transport
arrays to the agent, please consider using POST requests.<br>
For multi-dimensional arrays, <code>POST</code> method is mandatory.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Certain <em>tag values</em> are used to mark special
values.  A <code>null</code> value has to be
serialized as <code>[null]</code>, an empty String
as <code>""</code>. Tag values are not required for
POST requests.</p>
</div>
</div>
<div class="sect3">
<h4 id="_post_request_values"><a class="anchor" href="#_post_request_values"></a>POST request values</h4>
<div class="paragraph">
<p>POST request take advantage of the JSON type of the value
transfered. These are basic types for numbers
(<code>42</code> or <code>23.5</code>),
booleans (<code>true</code> or
<code>false</code>) and strings
(<code>"habanero"</code>). Also, JSON knows about
<code>null</code> values so no special 'tags' like
for GET requests are not required. Since JSON supports
intrinsically key-value maps and array types, these can be
used directly, too. I.e. if the JMX operation to execute
takes a <code>Map</code> argument, the argument
can be given as a JSON object. Be aware, however, that JSON
maps (objects) only support strings as keys.</p>
</div>
<div class="paragraph">
<p>The agent knows how to convert a JSON array to Java
Arrays (of a basic type) or Lists, depending on the
requirement as dictated by the MBeans operation or
attribute signature. Numbers in JSON are always transfered
as long or double values and are as well tried to fit
to the MBean&#8217;s signature. In case of an overflow
(e.g. when trying to treat a long with a too large value
as int), an exception is raised.</p>
</div>
<div class="paragraph">
<p>Enums can be converted from their canonical name. The
prerequisite for this is, that the Jolokia agent has
access to the Enum&#8217;s class. This is true for all Enums
shipped with the JDK (like
<code>TimeUnit</code>). Custom enums can not be
used for upstream serialization by default since the
Jolokia Agent is not able to construct an instance of it
because of missing type information.</p>
</div>
<div class="paragraph">
<p>Upstream serialization also supports
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/openmbean/OpenType.html" class="externalLink" target="_blank" rel="noopener">Open Types</a>.
If the signature of JMX exec operation or the value type
of a JMX attribute is a <code>OpenType</code>,
they are serialized as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SimpleType</code>s are extracted from their corresponding JSON type.</p>
</li>
<li>
<p><code>ArrayType</code> is extracted from a
<code>JSONArray</code> where the elements are
serialized recursively with this algorithms.
<code>ArrayType</code>s with element type
<code>CompositeType</code> or
<code>SimpleType</code> are supported. Jolokia also supports multi-dimensional <code>ArrayType</code>s.</p>
</li>
<li>
<p><code>CompositeType</code> is extracted
recursively from a <code>JSONObject</code>
where there the string keys must fit to the
<code>CompositeType</code>'s item names and
the values must be serializable as open types.</p>
</li>
<li>
<p><code>TabularType</code> is converted from
<code>JSONObject</code>. If it is single index
(i.e. has only one single index name), the
<code>JSONObject</code> must have the index
values as string keys and the map values are other
<code>JSONObject</code>'s representing the row
data. For <code>TabularType</code>'s with more
than one index name, the incoming
<code>JSONObject</code> must be a nested
object with each index as an additional
layer. E.g. the following JSON object works for
a <code>TabularType</code> with the two
index names <code>lastname</code> and
<code>firstname</code>, which are both of type <code>SimpleType.STRING</code>:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "Mann": {
    "Thomas": {
      "lastname": "Mann",
      "firstname": "Thomas",
      "birth": 1875
    },
    "Heinrich": {
      "lastname": "Mann",
      "firstname": "Heinrich",
      "birth": 1871
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TabularType</code> used by the MXBean
framework for serialization of Maps are translated
directly from maps. More details are explained in the
next section <a href="#serialization-mxbean">Jolokia and MXBeans</a>.</p>
</div>
<div class="paragraph">
<p><code>TabularType</code>'s with index values
which are <em>not</em> of type
<code>SimpleType</code> can be used, too.
However, in this case this simple nested map structure
is not enough, since keys of complex types
(e.g. <code>CompositeData</code> types) can
not be represented as JSON map keys. Instead, a
generic representation for
<code>TabularTypes</code> must be used. A
JSON object with two keys:
<code>indexNames</code> with an array of the
index names and <code>values</code> with an
array of rows containing objects which include the
index values plus any other values of the rows'
<code>CompositeType</code>. E.g. if in the
example above, the index would have been an
<code>User</code> with first- and lastname,
the JSON structure for setting the <code>TabularData</code> should
look like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "indexNames": [ "user" ],
  "values" : [
    { "user" : { "lastname": "Mann", "firstname": "Thomas" }, "birth": 1875 },
    { "user" : { "lastname": "Mann", "firstname": "Heinrich" }, "birth": 1871 }
  ]
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="serialization-mxbean"><a class="anchor" href="#serialization-mxbean"></a>Jolokia and MXBeans</h3>
<div class="paragraph">
<p>The <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/MXBean.html" class="externalLink" target="_blank" rel="noopener">MXBean Framework</a> is available in
the JDK since version 6 and allows for easy creation and
registration of own MBeans. MXBeans are some what the
successor for standard MBeans and support an annotation driven
as well as a naming convention driven programming model. The
most important difference to standard MBeans it the
restriction of MXBean to reference only open types.</p>
</div>
<div class="paragraph">
<p>Although to the outside only open types are exposed by the
MXBean framework, MXBean themselves can use more complex
data types. The framework will translate forth and back
between the custom and open types according to certain rules
as declared in the MXBean
<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.management/javax/management/MXBean.html" class="externalLink" target="_blank" rel="noopener">specification</a>.
Most of the translations to open types fits naturally to
Jolokia&#8217;s serialization, except for the translation of <code>Map</code>.</p>
</div>
<div class="paragraph">
<p>When an MXBean references a map, the MXBean framework
translates this map into a
<code>TabularData</code> with a fixed internal
structure, i.e. with an index <code>key</code> and
rows with keys <code>key</code> and
<code>value</code>. This leads directly to a JSON
representation which is quite artificial. E.g a map with
two keys <code>kind</code> and
<code>hotness</code> will be converted by the MXBean
framework to a TabularData object which in turn would be
translated by Jolokia to the following JSON structure</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "kind" : {
    "key": "kind",
    "value": "Habanero"
  },
  "hotness" : {
    "key": "hotness",
    "value": 10
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since this representation of a simple map is unnecessarily
complicated, Jolokia treats <code>TabularData</code>
of this kind (i.e. one index <code>key</code> and rows
with properties <code>key</code> and
<code>value</code>) specially in order to translate it
back (and forth) to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "kind" : "Habanero",
  "hotness" : 10
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="history"><a class="anchor" href="#history"></a>Tracking historical values</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Jolokia agents are able to keep requested values in memory
along with a timestamp. If history tracking is switched on,
then the agent will put the list of historical values specific
for this request into the response. History tracking is
toggled by an MBean operation on a Jolokia-owned MBean (see
<a href="jolokia_mbeans.html" class="xref page">Jolokia MBeans</a>). This has to be done individually for each
attribute or JMX operation to be tracked.</p>
</div>
<div class="paragraph">
<p>A <code>history</code> entry is contained in every
response for which history tracking was switched on. A certain
JMX operation on an Jolokia specific MBean has to be executed
to turn history tracking on for a specific attribute or
operation. See <a href="jolokia_mbeans.html" class="xref page">Jolokia MBeans</a> for details.The
<code>history</code> property of the JSON response
contains an array of json objects which have two attributes:
<code>value</code> containing the historical value
(which can be as complex as any other value) and
<code>timestamp</code> indicating the time when this
value was current (as measured by the server).
<a href="#response-example">JSON Response</a> has an example of a response
containing historical values.</p>
</div>
<div class="paragraph">
<p>For multi attribute read requests, the history entry in the
response is a JSON object instead of an array, where this
object&#8217;s attributes are the request&#8217;s attribute names and the
values are the history arrays as described above.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="protocol-proxy"><a class="anchor" href="#protocol-proxy"></a>Proxy requests</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For proxy requests, POST must be used as HTTP method so that
the given JSON request can contain an extra section for the
target which should be finally reached via this proxy
request. A typical proxy request looks like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type" : "read",
  "mbean" : "java.lang:type=Memory",
  "attribute" : "HeapMemoryUsage",
  "target" : {
    "url" : "service:jmx:rmi:///jndi/rmi://targethost:9999/jmxrmi",
    "user" : "jolokia",
    "password" : "s!cr!t"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>url</code> within the <code>target</code>
section is a JSR-160 service URL for the target server
reachable from within the proxy agent. <code>user</code>
and <code>password</code> are optional credentials used
for the JSR-160 Remote communication.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="discovery"><a class="anchor" href="#discovery"></a>Agent Discovery</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jolokia agents are able to respond to certain multicast
requests in order to allow clients to detect automatically
connection parameters. The agent URL to expose can be either
manually configured for an agent or an agent can try to detect
its URL automatically. This works fine for the JVM agent, for
the WAR agent it only works after the first HTTP request has
been processed by the agent. Due to limitations of the Servlet
API the agent servlet has no clue about its own URL until this
first request, which contains the request URL. Of course, the
URL obtained that way can be bogus as well, since the agent
may operate behind a proxy, too. So if in doubt, you should
configure the agent URL manually to allow external clients
to connect to the agent. The configuration options for enabling
multicast requests are described in the
<a href="agents/jvm.html#agent-jvm-config" class="xref page">JVM agent configuration options</a> and
<a href="agents/war.html#agent-war-init-params" class="xref page">Servlet init parameters</a> agent configuration
sections.</p>
</div>
<div class="paragraph">
<p>An agent which is enabled for multicast discovery will only
respond to a multicast request if the
<a href="security.html#security-policy" class="xref page">Policy based security</a> allows
connections from the source IP. Otherwise a multicast request
will be simply ignored. For example, if you have configured
your agent to only allow request from a central monitoring
host, only this host is able to detect these agents. Beside
security aspects it wouldn&#8217;t make sense to expose the URL as
any other host is not able to connect anyways.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.2.0 the Jolokia JVM agent has this
discovery feature enabled by default which can be switched off
via <code>--discoveryEnabled=true</code> command line parameter or the
corresponding configuration option. For the WAR agent and OSGi
agents this feature is switched off by default since auto
detection doesn&#8217;t always work. It can be enabled with the init
parameter <code>discoveryEnabled</code> (in which case the auto discovery
described above is enabled) or better with <code>discoveryAgentUrl</code>
with the URL. Alternatively, a system property can be used
with a <code>jolokia.</code> prefix
(e.g. <code>jolokia.discoveryEnabled</code>). More on the configuration
options can be found in the agent&#8217;s configuration sections.</p>
</div>
<div class="paragraph">
<p>For sending a multicast request discovery message, an UDP
message should be send to the address <code>239.192.48.84</code>, port
<code>24884</code> which contains a JSON message encoded in UTF-8 with
the following format</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type": "query"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use a tool like <a href="https://nmap.org/ncat/" class="externalLink" target="_blank" rel="noopener">netcat</a> or <a href="https://linux.die.net/man/1/socat" class="externalLink" target="_blank" rel="noopener">socat</a> to check the discovery:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ echo '{"type":"query"}' | socat STDIO UDP4-DATAGRAM:239.192.48.84:24884
{"agent_version":"2.4.0","agent_id":"jolokia-7778","type":"response","secured":false,"url":"http://192.168.0.165:7778/jolokia/"}{"agent_version":"2.4.0","agent_id":"jolokia-7779","type":"response","secured":false,"url":"http://192.168.0.165:7778/jolokia/"}</pre>
</div>
</div>
<div class="paragraph">
<p>Any agent enabled for discovery will respond to requester on the same socket with an answer which looks like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "agent_version": "2.4.0",
  "agent_id": "192.168.0.221-67980-7e985ce9-servlet",
  "server_product": "tomcat",
  "type": "response",
  "server_vendor": "Apache",
  "server_version": "10.1.16",
  "secured": true,
  "url": "http://192.168.0.221:8080/jolokia"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The response itself is a JSON object and is restricted to 8192
bytes maximum. The request type is either
<code>query</code> or <code>response</code>. A
<code>query</code> request is sent via multicast by any
interested client and each agent responds with a response of
type <code>response</code>.  Query requests contain
only the type as property. Responses are sent back to the
address and port of the sender of the query request.</p>
</div>
<table id="discovery-response" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 20. Response properties</caption>
<colgroup>
<col style="width: 15%;">
<col>
<col style="width: 30%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Request type, either <code>query</code> or
<code>response</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>query</code> or <code>response</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>agent_id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Each agent has a unique id which can be either provided
during startup of the agent in form of a configuration
parameter or being autodetected. If autodetected, the id has
several parts: The IP, the process id, hashcode of the agent
and its type. This field will be always provided.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>192.168.0.221-67980-7e985ce9-servlet</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>agent_description</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An optional description which can be used as a UI label if
given.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ServiceMix ESB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>url</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The URL how this agent can be contacted. This URL is
typically autodetected. For the JVM agent it should be
highly accurate. For the servlet based agents, it
depends. If configured via an initialisation parameter this
URL is used. If autodetected it is taken from the first HTTP
request processed by the servlet. Hence no URL is available
until this first request was processed. This property might
be empty.
When standard <code>-Djava.net.preferIPv6Addresses</code> option is set to <code>true</code>, the
returned URL should use IPv6 host address.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http://192.168.0.221:8080/jolokia</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>secured</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether the agent was configured for authentication or not.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>server_vendor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The vendor of the container the agent is running in. This
field is included if it could be automatically detected.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Apache</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>server_product</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The container product if detected</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tomcat</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>server_version</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The container&#8217;s version (if detected)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>10.1.16</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="versions"><a class="anchor" href="#versions"></a>Jolokia protocol versions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The protocol definition is versioned. It contains of a major
and minor version. Changes in the minor version are backward
compatible to other protocol with the same major
version. Major version changes incorporate possibly backwards
incompatible changes. This document describes the Jolokia
protocol version <strong><code>8.0</code></strong>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><strong>8.0 (since 2.1.0)</strong></dt>
<dd>
<p>We can now disable <code>request</code> field in the response
using <code>includeRequest</code> option. There&#8217;s new <code>listCache</code> parameter that
enables <em>optimized list response</em>. There&#8217;s also a <code>listKeys</code> parameter that adds <code>"keys"</code> field to MBeanInfo for an MBean - it contains keys obtained from Mbean&#8217;s ObjectName.</p>
</dd>
<dt class="hdlist1"><strong>7.3 (since 2.0.0)</strong></dt>
<dd>
<p>Support for <code>notification</code> command and related
JSON messages.</p>
</dd>
<dt class="hdlist1"><strong>7.2 (since 1.2.2)</strong></dt>
<dd>
<p>Paths can now be used with wildcards
(<code>*</code>) which match everything in the
selected level. They are especially useful with pattern
read requests.</p>
</dd>
<dt class="hdlist1"><strong>7.1 (since 1.2.0)</strong></dt>
<dd>
<p>The <code>version</code> command returns now the configuration
global information as well with the key <code>config</code> in the
returned value.</p>
</dd>
<dt class="hdlist1"><strong>7.0 (since 1.1.0)</strong></dt>
<dd>
<p>The <strong><code>maxDepth</code></strong>
parameter (either as processing parameter or as
configuration value) is now 1 based. I.e. 0 means always
"no limit" (be careful with this, though), 1 implies
truncating the value on the first level for READ
request. This was already true for LIST requests and the
other limit values (maxCollectionSize and maxObjects) so
this change is used in order to harmonize the overall
behaviour with regard to limits.</p>
<div class="paragraph">
<p>Enums are now serialized downstream (full support)
and upstream (for type accessible to the agent).</p>
</div>
<div class="paragraph">
<p>New query parameter options
<code>serializeException</code> (for setting an
<code>error_value</code> in case of an
exception), <code>canonicalNaming</code>
(influences how object names are returned) and
<code>includeStackTrace</code> (for adding or
omitting stacktraces in error responses).</p>
</div>
</dd>
<dt class="hdlist1"><strong>6.1 (since 1.0.2)</strong></dt>
<dd>
<p>Error responses contain now the original request as
well, for single and bulk requests.</p>
</dd>
<dt class="hdlist1"><strong>6.0 (since 1.0.0)</strong></dt>
<dd>
<p>Escaping has been changed from <code>/-/</code> to
<code>!/</code>. This affects GET Urls and
<em>inner paths</em>.</p>
</dd>
<dt class="hdlist1"><strong>5.0 (since 0.95)</strong></dt>
<dd>
<p><code>javax.management.openmbean.TabularData</code>
is serialized differently when generating the
response. In fact, the serialization as an array in
the former versions of this protocol is not correct,
since <code>TabularData</code> in fact is a
hash and not a list. It is now generated as map (or
multiple maps), depending on the declared
<em>index</em>. Also, access via path is now
an access via key, not a list index. For the special
case of MXBean map serialization, where the returned
<code>TabularData</code> has a fixed format
(i.e. with <code>key</code> and
<code>value</code> columns), the
<code>TabularData</code> is transformed to an
appropriate map.</p>
<div class="paragraph">
<p>Removed JSON property <code>modified</code> from
the serialized JSON representation of a File return
value since it duplicated the
<code>lastModified</code> property on the same
object.</p>
</div>
</dd>
<dt class="hdlist1"><strong>4.3 (since 0.91)</strong></dt>
<dd>
<p>The <code>list</code> operation supports a
<code>maxDepth</code> option for truncating the
answer.</p>
</dd>
<dt class="hdlist1"><strong>4.2 (since 0.90)</strong></dt>
<dd>
<p>Response values are returned in the native JSON
datatype, not always as strings as in previous versions
of this protocol. Parameter serialization for writing
attribute values or for arguments in exec operations has
been enhanced for POST requests, which are now
represented as native JSON types and not in a string
representation as before. GET requests still use a
simplified string representation.</p>
</dd>
<dt class="hdlist1"><strong>4.0 (17.10.2010)</strong></dt>
<dd>
<p>This is the initial version for Jolokia. Versions below 4 are
implemented by jmx4perl.</p>
</dd>
</dl>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. This document will avoid the term REST as much as possible in order to avoid provoking any dogmatic resentments.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. A backslash (<code>\</code>) can not be used, since most servlet container translate a backslash into a forward slash on the fly when given in an URL.
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. Seconds since 1.1.1970
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. If the server exception is a subtype of <code>MBeanException</code>, the wrapped exception&#8217;s message is used.
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. For JBoss older than version 7, there might be use cases when custom enums need to be serialized. In this case, the type information must be available to the agent, too. For the standard PlatformMBeanServer serialization should work always, regardless whether the customer enum type is accessible by the agent or not.
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. Conversion from a typed system to an untyped representation is obviously much easier than vice versa. Please note, that Jolokia does not replace a full blown JSON object serialization framework like Jackson. Nor does it use one in order to keep the agent small and simple with a low dependency count.
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="proxy_mode.html">Proxy Mode</a></span>
  <span class="next"><a href="jolokia_mbeans.html">Jolokia MBeans</a></span>
</nav>
</article>
  </div>
<footer class="footer">
  This page was built using the Antora default UI. The source code for this UI is licensed under the terms of the MPL-2.0 license. | Copyright © 2010 -
  2023 Roland Huß
</footer>
<script id="site-script" src="../_/js/site.js" data-ui-root-path="../_"></script>
<script async src="../_/js/vendor/highlight.js"></script>
</main>
</div>
  </body>
</html>
