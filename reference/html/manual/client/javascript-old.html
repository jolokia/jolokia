<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: Jolokia</title>
    <link rel="canonical" href="https://jolokia.org/manual/client/javascript-old.html">
    <meta name="generator" content="Antora 3.1.4">
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="stylesheet" href="../../_/css/jolokia.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://jolokia.org">Jolokia</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="manual" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">Jolokia Manual</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../architecture.html">Architecture</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../extensions.html">Extending Jolokia</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../agents.html">Agents</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../security.html">Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../proxy_mode.html">Proxy Mode</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../jolokia_protocol.html">Jolokia Protocol</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../jolokia_mbeans.html">Jolokia MBeans</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../clients.html">Clients</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../jolokia_jmx.html">JMX Support</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../spring.html">Spring Support</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Jolokia Manual</span>
    <span class="version"></span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="../index.html">Jolokia Manual</a></div>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
</nav>
<div class="edit-this-page"><a href="https://github.com/jolokia/jolokia/tree/main/src/documentation/manual/modules/ROOT/pages/client/javascript-old.adoc">Help improving this page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div class="sect1">
<h2 id="client-javascript-old"><a class="anchor" href="#client-javascript-old"></a>JavaScript Client Library (before ES modules)</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">NOTE</dt>
<dd>
<p>Since Jolokia 2.1.0 we recommend to use new (based on ES modules) version of Jolokia JavaScript libraries provided in these npm packages:</p>
<div class="ulist">
<ul>
<li>
<p><code>jolokia.js</code></p>
</li>
<li>
<p><code>@jolokia.js/simple</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The Jolokia JavaScript library provides a JavaScript API to the
to the Jolokia agent. It comes with two layers, a
basic one which allows for sending Jolokia requests to the agent
synchronously or asynchronously and one with a simplified API
which is less powerful but easier to use. This library supports
bulk requests, HTTP GET and POST requests and JSONP for querying
agents which are located on a different server.</p>
</div>
<div class="paragraph">
<p>All methods of this library are available via the
<code>Jolokia</code> client object, which needs to be
instantiated up-front. In the following example a client object is
created and then <em>used heap memory</em> is requested synchronously via
the simple API. The agent is deployed within the same webarchive
which also serves this script.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let j4p = new Jolokia("/jolokia");
let value = j4p.getAttribute("java.lang:type=Memory", "HeapMemoryUsage", "used");
console.log("Heap Memory used: " + value);</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="js-installation-old"><a class="anchor" href="#js-installation-old"></a>Installation</h3>
<div class="paragraph">
<p>The Jolokia JavaScript library is distributed in two parts, in
compressed and uncompressed forms:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>jolokia.js</code> and <code>jolokia-min.js</code></dt>
<dd>
<p>Base library containing the Jolokia object definition
which carries the <code>request()</code></p>
</dd>
<dt class="hdlist1"><code>jolokia-simple.js</code> and <code>jolokia-simple-min.js</code></dt>
<dd>
<p>Library containing the Jolokia simple API and which builds
up on <code>jolokia.js</code> It must be included
after <code>jolokia.js</code> since it adds methods
to the <code>Jolokia</code> object definition.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>All four files can be obtained from the
<a href="/download.html">download page</a>.
For production environments the compressed version
is highly recommended since the extensive API documentation
included in the original version is stripped off here. For Maven
users there is an even better way to integrate them, described in
<a href="#js-maven-old">Maven integration</a>.</p>
</div>
<div class="paragraph">
<p><code>jolokia.js</code> uses
<a href="https://www.jquery.com" class="externalLink" target="_blank" rel="noopener">jQuery</a>, which must be
included as well. Since Jolokia 2 is compliant with ES5, using <a href="https://github.com/douglascrockford/JSON-js" class="externalLink" target="_blank" rel="noopener">json2.js</a> is no longer required.</p>
</div>
<div class="paragraph">
<p>As sample HTML head for including all necessary parts looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;head&gt;
  &lt;script src="jquery-3.7.1.js"&gt;&lt;/script&gt;
  &lt;script src="jolokia-min.js"&gt;&lt;/script&gt;
  &lt;script src="jolokia-simple-min.js"&gt;&lt;/script&gt;
&lt;/head&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Jolokia client is always created as an instance of
<code>Jolokia</code>. Requests to the agent are sent
by calling methods on this object. The constructing function
takes a plain object, which provides default parameters which
are used in the <code>request()</code> if no
overriding are given there.</p>
</div>
</div>
<div class="sect2">
<h3 id="js-request-old"><a class="anchor" href="#js-request-old"></a>Usage</h3>
<div class="paragraph">
<p>All functions of this library are available as methods of the
<code>Jolokia</code> object. The <code>options</code> argument needs to be
instantiated as usual and it takes a set of default options, which
can be overwritten by subsequent requests. On the most basic
layer is a single <code>request()</code> method,
which takes two arguments: A request object and an optional
options object. For example, a synchronous request for obtaining
the agent&#8217;s version for a agent running on the same server which
delivered the JavaScript looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let j4p = new Jolokia({ "url": "/jolokia" });
let response = j4p.request({ "type": "version" }, { "method": "post" });
console.log("Agent Version: " + response.value.agent);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the constructor is used with a single string argument, this
value is considered to be the agent&#8217;s access URL. I.e. in the
example above the construction of the
<code>Jolokia</code> could have been performed with a
single string argument (<code>new Jolokia("/jolokia")</code>).</p>
</div>
<div class="sect3">
<h4 id="js-request-format-old"><a class="anchor" href="#js-request-format-old"></a>Requests</h4>
<div class="paragraph">
<p>Jolokia requests and responses are represented as JSON
objects. They have exactly the same format, which is expected
and returned by the agent as defined in
<a href="../jolokia_protocol.html" class="xref page">Jolokia Protocol</a> for POST requests. All request types are
supported.</p>
</div>
<div class="paragraph">
<p>The <code>request()</code> expects as its first
argument either a single request object or, for bulk requests,
an array of request objects. Depending on this for synchronous
operations either a single response JSON object is returned or
an array of responses (in the order of the initial request
array). For asynchronous request one or more callbacks are
called for each response separately. See
<a href="#js-request-sync-async-old">Operational modes</a> for details.</p>
</div>
<div class="paragraph">
<p>The following example shows a single and bulk request call to
the Jolokia agent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let j4p = new Jolokia({ "url": "/jolokia" });
let req1 = { "type": "read", "mbean": "java.lang:type=Memory", "attribute": "HeapMemoryUsage" };
let req2 = { "type": "list" };
let response = j4p.request(req1);
let responses = j4p.request([ req1, req2 ]);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="js-request-options-old"><a class="anchor" href="#js-request-options-old"></a>Request options</h4>
<div class="paragraph">
<p>Each request can be influenced by a set of optional options
provided either as default during construction of the
<code>Jolokia</code> object or as optional last
parameter for the request object. Also a request can carry a
<code>config</code> attribute, which can be used for all
processing parameters (<a href="../jolokia_protocol.html#processing-parameters" class="xref page">Processing parameters</a>).
The known options are summarized in <a href="#js-request-options-table-old">Table 1, &#8220;Request options&#8221;</a></p>
</div>
<table id="js-request-options-table-old" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Request options</caption>
<colgroup>
<col style="width: 20%;">
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>url</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Agent URL (mandatory)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Either "post" or "get" depending on the desired HTTP method
(case does not matter).  Please note, that bulk requests are
not possible with "get". On the other hand, JSONP requests
are not possible with "post" (which obviously implies that
bulk request cannot be used with JSONP requests). Also, when
using a <code>read</code> type request for multiple
attributes, this also can only be sent as "post"
requests. If not given, a HTTP method is determined
dynamically. If a method is selected which doesn&#8217;t fit to the
request, an error is raised.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>dataType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The type of data specified to the Ajax request. The default value is <code>json</code>,
and the response is parsed as JSON to an object. If the value is <code>text</code>,
the response is returned as plain text without parsing. The client is then
responsible for parsing the response. This can be useful when a custom JSON
parsing is necessary.<br>
Jolokia Simple API (jolokia-simple.js) doesn&#8217;t support <code>text</code> as dataType.<br>
<strong>Added since jolokia.js 2.0.2</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jsonp</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether the request should be sent via JSONP (a technique
for allowing cross domain request circumventing the infamous
"same-origin-policy"). This can be used only with HTTP "get"
requests.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>success</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Callback function which is called for a successful
request. The callback receives the response as single
argument. If no <code>success</code> callback is given, then
the request is performed synchronously and gives back the
response as return value. The value can be an array of
functions which is used for bulk requests to dispatch
multiple responses to multiple callbacks. See
<a href="#js-request-sync-async-old">Operational modes</a> for details.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>error</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Callback in case a Jolokia error occurs. A Jolokia error is
one, in which the HTTP request succeeded with a status code
of 200, but the response object contains a status other than
OK (200) which happens if the request JMX operation
fails. This callback receives the full Jolokia response
object (with a key <code>error</code> set). If no error
callback is given, but an asynchronous operation is
performed, the error response is printed to the JavaScript
console by default.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ajaxError</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Global error callback called when the Ajax request itself
failed. It obtains the same arguments as the error callback
given for <code>jQuery.ajax()</code>, i.e. the
<code>XmlHttpResponse</code>, a text status and an
error thrown. Refer to the jQuery documentation for more
information about this error handler.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>username</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A username used for HTTP authentication</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>password</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A password used for HTTP authentication</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>timeout</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timeout for the HTTP request</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxDepth</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maximum traversal depth for serialization of complex return values</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxCollectionSize</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maximum size of collections returned during serialization.
If larger, the collection is returned truncated.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>maxObjects</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Maximum number of objects contained in the response.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>serializeLong</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">How to serialize long values in the JSON response: <code>number</code> or <code>string</code>.
The default <code>number</code> simply serializes longs as numbers in JSON.
If set to <code>string</code>, longs are serialized as strings.
It can be useful when a JavaScript client consumes the JSON response,
because numbers greater than the max safe integer don&#8217;t retain their precision
in JavaScript.<br>
<strong>Added since Jolokia 2.0.3</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ignoreErrors</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If set to "true", errors during JMX operations and JSON
serialization are ignored. Otherwise if a single
deserialization fails, the whole request returns with an
error. This works only for certain operations like pattern
reads.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>canonicalNaming</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defaults to true for canonical (sorted) property lists on object names; if set to "false" then they are turned in their unsorted format.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>includeRequest</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether the response object should contain related request object.<br>
This option may be configured globally and overriden at request time.
When <code>false</code>, bulk responses have to be correlated with requests by matching
the requests using index number - responses come in the same order as requests.<br>
<strong>Added since Jolokia 2.1.0</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>listKeys</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether the response object for <code>list()</code> operation should contain <code>keys</code> field
that lists all the keys obtained from each <code>javax.management.ObjectName</code> of the response.
This may save you time parsing the name yourself.<br>
<strong>Added since Jolokia 2.1.0</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>listCache</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A flag (defaults to <code>false</code>) to enable <em>optimized list response</em>.<br>
With this flag enabled, <code>list()</code> operation returns a bit different structure (that&#8217;s why we&#8217;ve upgraded protocol version to <code>8.0</code>) where some MBeans may <em>point to</em> cached, shared MBeanInfo JSON fragment. This heavily decreases the size of <code>list()</code> response.<br>
<strong>Added since Jolokia 2.1.0</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>serializeException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If true then in case of an error, the exception itself is returned in
it JSON representation under the key <code>error_value</code>
in the response object.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>includeStackTrace</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">By default, a stacktrace is returned with every error (key: <code>stacktrace</code>)
This can be omitted by setting the value of this option to <code>false</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ifModifiedSince</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The <code>LIST</code> operations provides an
optimization in that it remembers, when the set of
registered MBeans has been changes last. If a timestamp
(in epoch seconds) is provided with this parameter, then
the LIST operation returns an empty response
(i.e. <code>value</code> is null) and a
<code>status</code> code of 304 (Not Modified) if
the MBeans haven&#8217;t changed. If you use the request
scheduler (<a href="#js-request-options-table-old">Table 1, &#8220;Request options&#8221;</a>)
then this feature can be used to get the callbacks called
only if a value is returned. For the normal request, the
error callback is called which must check the status itself.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="js-request-sync-async-old"><a class="anchor" href="#js-request-sync-async-old"></a>Operational modes</h4>
<div class="paragraph">
<p>Requests can be send either synchronously or asynchronously via
Ajax. If a <code>success</code> callback is given in the
request options, the request is performed asynchronously via an
Ajax HTTP request. The callback gets these arguments: a Jolokia JSON
response object (see <a href="../jolokia_protocol.html#request-response" class="xref page">Requests and Responses</a>) and an
integer index indicating for which response this callback is being
called. For bulk requests, this index corresponds to the array
index of the request which lead to this response. The value of
this option can be an array of callback functions which are
called in a round robin fashion when multiple responses are
received in case of bulk requests. These callbacks are called
only when the returned Jolokia response has a status code of
<code>200</code>, otherwise the callback(s) given with
the <code>error</code> option are consulted. If no error
callback is given, the error is printed on the console by
default. As for success callbacks, error callbacks receive the
Jolokia error response as a JSON object.</p>
</div>
<div class="paragraph">
<p>The following example shows asynchronous requests for a single
Jolokia request as well as for bulk request with multiple
callbacks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let j4p = new Jolokia("/jolokia");

// Single request with a single success callback
j4p.request(
  {
    "type": "read",
    "mbean": "java.lang:type=Memory",
    "attribute": "HeapMemoryUsage"
  },
  {
    "success": function(response) {
      if (response.value.used / response.value.max &gt; 0.9) {
        alert("90% of heap memory exceeded");
      }
    },
    "error": function(response) {
      alert("Jolokia request failed: " + response.error);
    }
  }
);

// Bulk request with multiple callbacks
j4p.request(
  [
    {
      "type": "read",
      "mbean": "java.lang:type=Threading",
      "attribute": "ThreadCount"
    },
    {
      "type": "read",
      "mbean": "java.lang:type=Runtime",
      "attribute": [ "VmName", "VmVendor" ]
    }
  ],
  {
    "success": [
      function(response) {
        console.log("Number of threads: " + response.value);
      },
      function(response) {
        console.log("JVM: " + response.value.VmName + " -- " + response.value.VmVendor);
      }
    ],
    "error": function(response) {
      alert("Jolokia request failed: " + response.error);
    }
  }
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both callbacks, <code>success</code> and
<code>error</code>, are only called when the Ajax
request succeeds. In case of an error on the HTTP level, the
callback <code>ajaxError</code> is called with the
<code>XMLHttpRequest</code>, a
<code>textStatus</code> and an optional exception
object. It has the same signature as the underlying
<code>error</code> callback of the
<code>jQuery.ajax()</code> call. (See the
<a href="https://api.jquery.com/jQuery.ajax/" class="externalLink" target="_blank" rel="noopener">jQuery documentation</a>
for details).</p>
</div>
<div class="paragraph">
<p>The Jolokia agent also supports
<a href="https://en.wikipedia.org/wiki/JSONP" class="externalLink" target="_blank" rel="noopener">JSONP</a> requests
for cases where the Jolokia agent is served on a different server or port
than the JavaScript client. By default, such access is forbidden by the so called
<em>same-origin-policy</em>. To switch on JSONP, the
option <code>jsonp</code> should be set to
<code>"true"</code>.</p>
</div>
<div class="paragraph">
<p>As explained in <a href="../jolokia_protocol.html#request-response" class="xref page">Requests and Responses</a> the Jolokia
agent supports two HTTP methods, <code>GET</code> and
<code>POST</code>. <code>POST</code> is more
powerful since it supports more features. e.g. bulk requests and
JMX proxy requests are only possible with POST. By default, the
Jolokia JavaScript library selects an HTTP method automatically,
which is <code>GET</code> for simple cases and <code>POST</code>
for more sophisticated requests. The HTTP method can be
overridden by setting the option <code>method</code> to
<code>"get"</code> or <code>"post"</code>.</p>
</div>
<div class="paragraph">
<p>There are some limitations in choosing the HTTP method depending
on the request and other options given:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Bulk requests (i.e. an array of multiple requests) can only be
used with <code>POST</code>.</p>
</li>
<li>
<p><code>READ</code> requests for multiple attributes
(i.e. the <code>attribute</code> request parameter is
an array of string values) can only be used with
<code>POST</code>.</p>
</li>
<li>
<p>The JMX proxy mode (see <a href="../proxy_mode.html" class="xref page">Proxy Mode</a>) can only be used
with <code>POST</code>.</p>
</li>
<li>
<p>JSONP can only be used with <code>GET</code> and only
in asynchronous mode (i.e. a <code>success</code>
callback must be given). This is a limitation of the JSONP
technique itself.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The restrictions above imply, that JSONP can only be used for
single, simple requests and not for JMX proxy calls.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="js-simple-old"><a class="anchor" href="#js-simple-old"></a>Simple API</h3>
<div class="paragraph">
<p>Building upon the basic
<code>Jolokia.request()</code> method, a simplified
access API is available. It is contained in
<code>jolokia-simple.js</code> which must be included after
<code>jolokia.js</code>. This API provides dedicated
method for the various request types and supports all options as
described in <a href="#js-request-options-table-old">Table 1, &#8220;Request options&#8221;</a>. There
is one notable difference for asynchronous callbacks and
synchronous return values though: In case of a successful call,
the callback is fed with the response&#8217;s
<code>value</code> object, not the full response
(i.e. <code>response.value</code>). Similar, for synchronous
operations the value itself is returned. In case of an error,
either an <code>error</code> callback is called with the
full response object or an <code>Error</code> is
thrown for synchronous operations.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>getAttribute(mbean, attribute, path, opts)</code></dt>
<dd>
<p>This method returns the value of an JMX attribute
<code>attribute</code> of an MBean <code>mbean</code>. A path
can be optionally given, and the optional request options are
given as last argument(s). The return value for synchronous
operations are the attribute&#8217;s value, for asynchronous
operations (i.e. <code>opts.success != null</code>) it is
<code>null</code>. See <a href="../protocol/read.html" class="xref page">Reading attributes (read)</a> for
details.</p>
<div class="paragraph">
<p>For example, the following method call can be used
to synchronously fetch the current heap memory usage:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let memoryUsed = j4p.getAttribute("java.lang:type=Memory", "HeapMemoryUsage", "used");</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>setAttribute(mbean, attribute, value, path, opts)</code></dt>
<dd>
<p>For setting an JMX attribute, this method takes the MBean&#8217;s
name <code>mbean</code>, the attribute
<code>attribute</code> and the value to set as
<code>value</code>. The optional <code>path</code> is the
<em>inner path</em> of the attribute on which
to set the value (see <a href="../protocol/write.html" class="xref page">Writing attributes (write)</a> for
details). The old value of the attribute is returned or
given to a <code>success</code> callback.</p>
<div class="paragraph">
<p>To enable verbose mode in the memory-handling beans, use</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let gsLoggingWasOn = j4p.setAttribute("java.lang:type=Memory", "Verbose", true);</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>execute(mbean, operation, arg1, arg2, &#8230;&#8203;, opts)</code></dt>
<dd>
<p>With this method, a JMX operation can be executed on the
MBean <code>mbean</code>. Beside the operation&#8217;s name
<code>operation</code>, one or more arguments can be given
depending on the signature of the JMX operation. The
return value is the return value of the operation. See
<a href="../protocol/exec.html" class="xref page">Executing JMX operations (exec)</a> for details.</p>
<div class="paragraph">
<p>The following exampled asynchronously fetches a thread dump
as a JSON object and logs it into the console:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">j4p.execute("java.lang:type=Threading", "dumpAllThreads(boolean,boolean)", true, true, {
  "success": function(value) {
    console.log(JSON.stringify(value));
  }
});</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>search(mBeanPattern, opts)</code></dt>
<dd>
<p>Searches for one or more MBeans whose object names fit the
pattern <code>mBeanPattern</code>. The return value is a list
of strings with the matching MBean names or <code>null</code>
if none is found. See <a href="../protocol/search.html" class="xref page">Searching MBeans (search)</a> for details.</p>
<div class="paragraph">
<p>The following example looks up all application servers
available in all domains:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let servletNames = j4p.search("*:j2eeType=Servlet,*");</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>list(path, opts)</code></dt>
<dd>
<p>For getting meta information about registered MBeans,
the <code>list</code> command can be used. The
optional <code>path</code> points into this meta
information for retrieving partial information. The format
of the return value is described in detail in
<a href="../protocol/list.html" class="xref page">Listing MBeans (list)</a>.</p>
<div class="paragraph">
<p>This example fetches only the meta information for the
attributes of the
<code>java.lang:type=OperatingSystem</code> MBean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let attributesMeta = j4p.list("java.lang/type=OperatingSystem/attr");</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>version(opts)</code></dt>
<dd>
<p>The <code>version</code> method returns the
agent&#8217;s version, the protocol version, and possibly some
additional server-specific information. See
<a href="../protocol/version.html" class="xref page">Getting the agent version (version)</a> for more information about this
method.</p>
<div class="paragraph">
<p>A sample return value for an Apache Tomcat server looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "agent": "2.1.2",
  "protocol": "7.2",
  "details": {
    "agent_version": "2.0.0-SNAPSHOT",
    "agent_id": "192.168.0.221-72527-6baa8838-servlet",
    "server_product": "tomcat",
    "server_vendor": "Apache",
    "server_version": "10.1.16",
    "secured": true,
    "url": "http://192.168.0.221:8080/jolokia"
  },
  "id": "192.168.0.221-72527-6baa8838-servlet",
  "config": {
    ...
  },
  "info": {
    "proxy": {},
    "jmx": {}
  }
}</code></pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="js-poller-old"><a class="anchor" href="#js-poller-old"></a>Request scheduler</h3>
<div class="paragraph">
<p>A <code>Jolokia</code> object can be also used for
periodically sending requests to the agent. Therefore requests
can be registered to the client object, and a poller can be
started and stopped. All registered requests are send at once
with a single bulk request so this is a quite efficient method for
periodically polling multiple values.</p>
</div>
<div class="paragraph">
<p>Here is a simple example, which queries the heap memory usage
every 10 seconds and prints out the used memory on the console:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let j4p = new Jolokia("/jolokia")
handle = j4p.register(function(resp) {
  console.log("HeapMemory used: " + resp.value);
},
{
  "type": "read",
  "mbean": "java.lang:type=Memory",
  "attribute": "HeapMemoryUsage", "path": "used"
});

j4p.start(10000);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>handle = j4p.register(callback, request, request,&#8230;&#8203;.)</code></dt>
<dd>
<p>This method registers one or more request for being
periodically fetched. <code>callback</code> can be either a
function or an object.</p>
<div class="paragraph">
<p>If a function is given or an object with an attribute
<code>callback</code> holding a function, then this
function is called with all responses received as
argument, regardless whether the individual response
indicates a success or error state.</p>
</div>
<div class="paragraph">
<p>If the first argument is an object with two callback
attributes <code>success</code> and <code>error</code>,
these functions are called for <em>each</em> response
separately, depending whether the response indicates
success or an error state. If multiple requests have been
registered along with this callback object, the callback
is called multiple times, one for each request in the same
order as the request are given.  As second argument, the
handle which is returned by this method is given and as
third argument the index within the list of requests.</p>
</div>
<div class="paragraph">
<p>If the first argument is an object, an additional
<code>config</code> attribute with processing
parameters can be given which is used as default for the
registered requests. Requests with a
<code>config</code> section take precedence.</p>
</div>
<div class="paragraph">
<p>Furthermore, if a <code>onlyIfModified:
true</code> exists in the callback object, then the
<code>success</code> and <code>error</code>
callbacks are called only if the result changed on the
server side. Currently, this is supported for the
<code>list</code> operation only in which case the
callback is only called when MBean has been registered or
deregistered since the last call of the scheduler. If a
single <code>callback</code> function is used
which gets all responses for a job at once, then this
function is called only with the responses, which carry a
value. If none of the registered requests produced a
response with value (i.e. the server decided that there
was no update for any request), then a call to the callback function is
skipped completely.</p>
</div>
<div class="paragraph">
<p><code>register()</code> returns a handle which can be used
later for unregistering these requests.</p>
</div>
<div class="paragraph">
<p>In the following example two requests are registered along
with a single callback function, which takes two responses
as arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">handle = j4p.register(function(resp1, resp2) {
  console.log("HeapMemory used: " + resp1.value);
  console.log("ThreadCount: " + resp2.value);
},
{
  "type": "read",
  "mbean": "java.lang:type=Memory",
  "attribute": "HeapMemoryUsage",
  "path": "used"
},
{
  "type": "read",
  "mbean": "java.lang:type=Threading",
  "attribute": "ThreadCount"
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the next example, a dedicated <code>success</code>
and <code>error</code> callback are provided, which are
called individually for each request (in the given
order):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">j4p.register(
  {
    "success": function(resp) {
      console.log("MBean: " + resp.mbean + ", attr: " + resp.attribute + ", value: " + resp.value);
    },
    "error": function(resp) {
      console.log("Error: " + resp.error_text);
    },
    config: {
      "serializeException": true
    },
    "onlyIfModified": true
  },
  {
    "type": "list",
    "config": {
      "maxDepth": 2
    }
  },
  {
    "type": "read",
    "mbean": "java.lang:type=Threading",
    "attribute": "ThreadCount",
    "config": {
      "ignoreErrors": true
    }
  },
  {
    "type": "read",
    "mbean": "bla.blu:type=foo",
    "attribute": "blubber"
  }
);</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>j4p.unregister(handle)</code></dt>
<dd>
<p>Unregister one or more requests registered with
<code>handle</code> so that they are no longer polled
with the scheduler.</p>
</dd>
<dt class="hdlist1"><code>j4p.jobs()</code></dt>
<dd>
<p>Return an array of handles for all registered jobs. This array can be freely manipulated, its a copy of
the handle list.</p>
</dd>
<dt class="hdlist1"><code>j4p.start(period)</code></dt>
<dd>
<p>Startup the scheduler for requeting the agent every
<code>period</code> milliseconds. If the scheduler is
already running, it adapts its scheduling period according
to the given argument. If no <code>period</code> is given,
the period provided during construction time (with the
option <code>fetchInterval</code>) is used. The default
value is 30 seconds.</p>
</dd>
<dt class="hdlist1"><code>j4p.stop()</code></dt>
<dd>
<p>Stop the scheduler. If the scheduler is not running,
nothing happens. The scheduler can be restarted after it
has been stopped.</p>
</dd>
<dt class="hdlist1"><code>j4p.isRunning()</code></dt>
<dd>
<p>Checks whether the scheduler is running. Returns
<code>true</code> if this is the case, <code>false</code>
otherwise.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="js-maven-old"><a class="anchor" href="#js-maven-old"></a>Maven integration</h3>
<div class="paragraph">
<p>For Maven users' convenience, the Jolokia JavaScript package is
also available as a JavaScript artifact. It can be easily
included with help of the
<code>javascript-maven-plugin</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows a sample configuration which could
be used within a <code>pom.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;project&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.jolokia&lt;/groupId&gt;
      &lt;artifactId&gt;jolokia-client-javascript&lt;/artifactId&gt;
      &lt;type&gt;javascript&lt;/type&gt;
      &lt;version&gt;2.1.2&lt;/version&gt;
    &lt;/dependency&gt;
    ....
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;com.devspan.mojo.javascript&lt;/groupId&gt;
        &lt;artifactId&gt;javascript-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;0.9.3&lt;/version&gt;
        &lt;extensions&gt;true&lt;/extensions&gt;
        &lt;configuration&gt;
          &lt;useArtifactId&gt;false&lt;/useArtifactId&gt;
        &lt;/configuration&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;war-package&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
      ...
    &lt;/plugins&gt;
    ...
  &lt;/build&gt;
  ...
&lt;/project&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, in your webapp project, <code>jolokia.js</code>,
<code>jolokia-simple.js</code> and
<code>json2.js</code> can be found in the
<code>scripts/lib</code> directory (relative to the
top level of you WAR). In order to include it in your HTML
files use something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;head&gt;
  &lt;script src="jquery-3.7.1.js"&gt;&lt;/script&gt;
  &lt;script src="scripts/lib/jolokia.js"&gt;&lt;/script&gt;
  &lt;script src="scripts/lib/jolokia-simple.js"&gt;&lt;/script&gt;
&lt;/head&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>jquery.js</code> has to be included on its own,
though and is not included within the dependency. If the
compressed version of <code>jolokia.js</code> should
be used, add a
<code>classifier="compressed"</code> to the
<code>jolokia-client-javascript</code> dependency, and
include <code>scripts/lib/jolokia-min.js</code></p>
</div>
<div class="paragraph">
<p>A full working example can be found in the Jolokia sources at
<code>examples/client-javascript-test-app/pom.xml</code>.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
<footer class="footer">
  This page was built using the Antora default UI. The source code for this UI is licensed under the terms of the MPL-2.0 license. | Copyright © 2010 -
  2023 Roland Huß
</footer>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
</main>
</div>
  </body>
</html>
